<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from www.lua.org/manual/5.1/es/manual.html by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 29 Sep 2011 12:47:35 GMT -->
<head>
<title>Manual de Referencia de Lua 5.1</title>
<link rel="stylesheet" type="text/css" href="http://www.lua.org/lua.css">
<link rel="stylesheet" type="text/css" href="http://www.lua.org/manual/manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</head>

<body>

<hr>
<h1>
<a href="http://www.lua.org/home.html"><img src="http://www.lua.org/images/logo.gif" alt="" border="0"></a>
Manual de Referencia de Lua 5.1
</h1>

por Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
<p>
(Traducción de Julio Manuel Fernández-Díaz; véanse las notas sobre la
misma al <a href="#terminos">final del documento</a>.)

<p>
<small>
Copyright &copy; 2007&ndash;2008 Lua.org, PUC-Rio.
Libremente disponible bajo los términos de la 
<a href="http://www.lua.org/license.html">licencia de Lua</a>.
</small>


<hr>
<p>

<a href="index-2.html#contents">contenido</A>
&middot;
<a href="index-2.html#index">índice</A>
&middot;
<A HREF="../index.html">english</A>
&middot;
<A HREF="../pt/index.html">português</A>
&middot;
<A HREF="index.html">español</A>



<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.45 2008/01/19 00:17:30 roberto Exp $ -->

<h1>1 - <a name="1">Introducción</a></h1>

<p>Lua es un lenguage de programación extensible diseñado para una programación procedimental general con utilidades para la descripción de datos. También ofrece un buen soporte para la programación orientada a objetos, programación funcional y programación orientada a datos. Se pretende que Lua sea usado como un lenguaje de <a href="#script"><em>script</em></a> potente y ligero para cualquier programa que lo necesite. Lua está implementado como una biblioteca escrita en C <em>limpio</em> (esto es, en el subconjunto común de ANSI C y C++).

<p>Siendo un lenguaje de extensión, Lua no tiene noción de programa principal (<em>main</em>): sólo funciona <em>embebido</em> en un cliente anfitrión, denominado <em>programa contenedor</em> o simplemente anfitrión (<em>host</em>). Éste puede invocar funciones para ejecutar un trozo de código Lua, puede escribir y leer variables de Lua y puede registrar funciones C para que sean llamadas por el código Lua. A través del uso de funciones C, Lua puede ser aumentado para abarcar un amplio rango de diferentes dominios, creando entonces lenguajes de programación personalizados que comparten el mismo marco sintáctico. La distribución de Lua incluye un programa anfitrión de muestra denominado <code>lua</code>, que usa la biblioteca de Lua para ofrecer un intérprete de Lua completo e independiente.


<p>Lua es software libre, y se proporciona, como es usual, sin garantías, como se establece en su licencia. La implementación descrita en este manual está disponible en el sitio web oficial de Lua, <code>www.lua.org</code>.

<p>Como cualquier otro manual de referencia, este documento es parco en algunos lugares. Para una discusión de las decisiones detrás del diseño de Lua, véanse los artículos técnicos disponibles en el sitio web de Lua. Para una detallada introducción a la programación en Lua, véase el libro de Roberto, <em>Programming in Lua (Second Edition)</em>.

<p>
<h1>2 - <a name="2">El lenguaje</a></h1>

<p>Esta sección describe el léxico, la sintaxis y la semántica de Lua. En otras palabras, esta sección describe qué elementos (<em>tokens</em>) son válidos, cómo deben combinarse y qué significa su combinación.

<p>Las construcciones del lenguaje se explicarán usando la notación BNF extendida usual, en la que {<em>a</em>} significa 0 o más <em>a</em>es, y [<em>a</em>] significa una <em>a</em> opcional. Los símbolos no terminales se muestran en <em>itálica</em>, las palabras clave (<em>keywords</em>) se muestran en <b>negrita</b>, y los otros símbolos terminales se muestran en un tipo de letra de paso fijo (<code>typewriter</code>), encerrada entre comillas simples. La sintaxis completa de Lua se encuentra al final de este manual.

<p><a name="2.1"></a><h2>2.1 - Convecciones léxicas</h2>

<p>Los <em>nombres</em> (también llamados <em>identificadores</em>) en Lua pueden ser cualquier tira de caracteres (<a href="#string"><em>string</em></a>) sólo con letras, dígitos y caracteres de subrayado (<em>underscore</em>), no comenzando por un dígito. Esto coincide con la definición de los nombres en la mayoría de los lenguajes. (La definición de letra depende de la implementación local actual a través del sistema <em>locale</em>: cualquier carácter considerado alfabético en el sistema local puede ser usado en un identificador.) Los identificadores se usan para nombrar variables y campos de tablas.

<p>Las siguientes <em>palabras clave</em> (<em>keywords</em>) están reservadas y no pueden
usarse como nombres:

<pre>       and       break     do        else      elseif
       end       false     for       function  if
       in        local     nil       not       or
       repeat    return    then      true      until     while
</pre>

<p>En Lua las letras mayúsculas y las minúsculas se consideran diferentes: <code>and</code> es una palabra reservada, pero <code>And</code> y <code>AND</code> son dos nombres diferentes válidos. Como convención, los nombres que comienzan por un subrayado seguido por letras en mayúsculas (como <a href="#pdf-_VERSION"><code>_VERSION</code></a>) están reservados para uso como variables globales internas de Lua.

<p>Los siguientes <em>strings</em> denotan otros elementos:
<pre>       +     -     *     /     %     ^     #
       ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
       (     )     {     }     [     ]
       ;     :     ,     .     ..    ...
</pre>

<p>Los <em>strings literales</em> pueden ser delimitados por comillas simples (apóstrofes) o dobles, y pueden contener las siguientes secuencias de <em>escape</em> de C:
'<code>\a</code>' (pitido, <em>bell</em>)
'<code>\b</code>' (retroceso, <em>backspace</em>),
'<code>\f</code>' (salto de página, <em>form feed</em>),
'<code>\n</code>' (nueva línea, <em>newline</em>),
'<code>\r</code>' (retorno de carro, <em>carriage return</em>),
'<code>\t</code>' (tabulador horizontal, <em>horizontal tab</em>),
'<code>\v</code>' (tabulador vertical, <em>vertical tab</em>),
'<code>\\</code>' (barra inversa, <em>backslash</em>),
'<code>\"</code>' (comilla doble, <em>quotation mark</em> o <em>double quote</em>) y
'<code>\'</code>' (apóstrofe, <em>apostrophe</em> o <em>single quote</em>).

Además, una '<code>\</code><em>newline</em>' (esto es, una barra inversa seguida por un salto de línea real) produce un salto de línea en el <em>string</em>. Un carácter en un <em>string</em> puede también especificarse por su valor numérico usando la secuencia de escape '<code>\</code><em>ddd</em>', donde <em>ddd</em> es una secuencia de tres dígitos decimales. (Tenga presente que si la secuencia numérica de escape está seguida de un dígito debe ser expresada usando exactamente tres dígitos.) Los <em>strings</em> en Lua pueden contener cualquier valor de 8 bits, incluyendo el carácter cero, el cual puede ser especificado mediante '<code>\0</code>'.

<p>Para poner una comilla (simple) doble, una barra inversa, un retorno de carro o un carácter cero dentro de un <em>string</em> literal encerrado por comillas (simples) dobles se debe usar una secuencia de escape. Cualquier otro carácter puede ser incluido en el literal. (Algunos caracteres de control pueden causar problemas con el sistema de ficheros, pero Lua no tiene problemas con ellos.)

<p>Los <em>strings</em> literales pueden definirse usando un formato largo, encerrados en <em>corchetes largos</em>. Definimos un <em>corchete largo de abrir de nivel n</em> como un corchete de abrir seguido de <em>n</em> signos igual (=) seguidos de otro corchete de abrir. Así, un corchete largo de abrir de nivel 0 se escribe <code>[[</code>, un corchete largo de abrir de nivel 1 se escribe <code>[=[</code>, y así sucesivamente. Los <em>corchetes largos de cerrar</em> se define de manera similar; por ejemplo, un corchete largo de cerrar de nivel 4 se expresa <code>]====]</code>. Un <em>string</em> largo comienza en un corchete largo de abrir de cualquier nivel y termina en el primer corchete largo de cerrar del mismo nivel. Los <em>strings</em> literales delimitados de esta manera pueden extenderse por varias líneas, las secuencias de escape no son interpretadas y se ignoran los corchetes largos de cualquier otro nivel. Por tanto, pueden contener cualquier cosa excepto un corchete de cerrar del mismo nivel o caracteres cero.

<p>Por conveniencia, cuando un corchete largo de abrir es seguido inmediatamente de un carácter de nueva línea, éste no es incluido en el <em>string</em>. Por ejemplo, usando el código de caracteres ASCII (en el cual '<code>a</code>' se codifica como 97, el carácter de nueva línea se codifica como 10, y '<code>1</code>' se codifica como 49), los cinco literales siguientes denotan el mismo <em>string</em>:
<pre>      a = 'alo\n123"'
      a = "alo\n123\""
      a = '\97lo\10\04923"'
      a = [[alo
      123"]]
      a = [==[
      alo
      123"]==]
</pre>

<p>Las <em>constantes numéricas</em> pueden contener una parte decimal opcional y también un exponente opcional. Lua también acepta constantes enteras hexadecimales, escritas anteponiendo el prefijo <code>0x</code>. Algunos ejemplos de constantes numéricas válidas son
<pre>       3       3.0     3.1416  314.16e-2   0.31416E1  0xff  0x56
</pre>

<p>Los <em>comentarios</em> comienzan con un doble guión (<code>--</code>) en cualquier lugar fuera de un <em>string</em>. Si el texto que sigue inmediatamente después de <code>--</code> no es un corchete largo de abrir el comentario es <em>corto</em> y llega hasta el final de línea. En otro caso tenemos un comentario <em>largo</em>, que alcanza hasta el correspondiente corchete largo de cerrar. Los comentarios largos se usan frecuentemente para deshabilitar temporalmente trozos de código.

<p><a name="2.2"></a><h2>2.2 - Valores y tipos</h2>

<p>Lua es un <em>lenguaje dinámicamente tipado</em>. Esto significa que las variables no tienen tipos; sólo tienen tipo los valores. No existen definiciones de tipo en el lenguaje. Todos los valores almacenan su propio tipo.

<p>Todos los valores en Lua son <em>valores de primera clase</em>. Esto significa que todos ellos pueden ser almacenados en variables, pueden ser pasados como argumentos de funciones, y también ser devueltos como resultados.

<p>Existen ocho tipos básicos en Lua:
<em>nil</em>, <em>boolean</em>, <em>number</em>,
<em>string</em>, <em>function</em>, <em>userdata</em>,
<em>thread</em> y <em>table</em>.
<em>Nil</em> es el tipo del valor <b>nil</b>, cuya principal propiedad es ser
diferente de cualquier otro valor; normalmente representa la ausencia de un valor útil.
<em>Boolean</em> es el tipo de los valores <b>false</b> (falso) y <b>true</b> (verdadero).
Tanto <b>nil</b> como <b>false</b> hacen una condición falsa;
cualquier otro valor la hace verdadera.
<em>Number</em> representa números reales (en coma flotante y doble precision).
(Es fácil construir intérpretes de Lua que usen otra representación interna para 
los números, ya sea en coma flotante con precisión simple o enteros largos. 
Véase el fichero <code>luaconf.h</code>.)
<em>String</em> representa una tira de caracteres.

Lua trabaja con 8 bits: los <em>strings</em> pueden contener cualquier carácter de 8 bits, incluyendo el carácter cero ('<code>\0</code>') (véase <a href="#2.1">&sect;2.1</a>).

<p>Lua puede llamar (y manejar) funciones escritas en Lua y funciones escritas en C (véase <a href="#2.5.8">&sect;2.5.8</a>).

<p>El tipo <a href="#userdata"><em>userdata</em></a> se incluye para permitir guardar en variables de Lua datos arbitrarios en C. Este tipo corresponde a bloques de memoria y no tienen asociadas operaciones predefinidas en Lua, excepto la asignación y el test de identidad. Sin embargo, usando <a href="#2.8">&sect;<em>metatablas</em></a>, el programador puede definir operaciones asociadas a valores de tipo <em>userdata</em> (véase <a href="#2.8">&sect;2.8</a>). Los valores de este tipo no pueden ser creados o modificados en Lua, sino sólo a través de la API de C. Esto garantiza la integridad de los datos propiedad del programa anfitrión.

<p>El tipo <a href="#thread"><em>thread</em></a> representa procesos de ejecución y es usado para implementar co-rutinas (véase <a href="#2.11">&sect;2.11</a>). No deben confundirse los procesos de Lua con los del sistema operativo. Lua soporta co-rutinas en todos los sistemas, incluso en aquéllos que no soporten procesos.

<p>El tipo <em>table</em> (tabla) implementa <a href="#arrays"><em>arrays</em></a> asociativos, esto es, <em>arrays</em> que pueden ser indexados no sólo con números, sino también con cualquier valor (excepto <b>nil</b>). Las tablas pueden ser <em>heterogéneas</em>, ya que pueden contener valores de todos los tipos (excepto <b>nil</b>). Las tablas son el único mecanismo de estructuración de datos en Lua; pueden ser usadas para representar <em>arrays</em> ordinarios, tablas de símbolos, conjuntos, registros, grafos, árboles, etc. Para representar registros Lua usa el nombre del campo como índice. El lenguaje soporta esta representación haciendo la notación <code>b.nombre</code> equivalente a <code>b["nombre"]</code>. Existen varias maneras convenientes de crear tablas en Lua (véase <a href="#2.5.7">&sect;2.5.7</a>).

<p>Como índices, también los valores de los campos de una tabla pueden ser de cualquier tipo (excepto <b>nil</b>). En particular, debido a que las funciones son valores de primera clase, los campos de las tablas pueden contener funciones. Entonces las tablas pueden contener también <em>métodos</em> (véase <a href="#2.5.9">&sect;2.5.9</a>).

<p>Los valores de las tablas, las funciones, los procesos y los <em>userdata</em> (completos) son <em>objetos</em>: las variables no <em>contienen</em> realmente esos valores, sino que sólo los <em>referencian</em>. La asignación, el paso de argumentos y el retorno de las funciones siempre manejan referencias a esos valores; esas operaciones no implican ningún tipo de copia.

<p>La función de biblioteca <a href="#pdf-type"><code>type</code></a> retorna un <em>string</em> que describe el tipo de un valor dado.

<p><a name="2.2.1"></a><h3>2.2.1 - Coerción</h3>

<p>Lua puede convertir automáticamente entre valores <em>string</em> y valores numéricos en tiempo de ejecución. Cualquier operación aritmética aplicada a un <em>string</em> intenta convertir el mismo en un número, siguiendo las reglas normales de conversión. Y viceversa, cuando un número se usa donde se espera un <em>string</em> el número se convierte a <em>string</em>, con un formato razonable. Para un control completo en la conversión de números en <em>strings</em> debe usarse la función <code>format</code> de la biblioteca de manejo de <em>strings</em> (véase <a href="#pdf-string.format"><code>string.format</code></a>).

<p><a name="2.3"></a><h2>2.3 - Variables</h2>

<p>Las variables son lugares donde se almacenan valores.

Existen tres tipos de variables en Lua: globales, locales y campos de tabla.

<p>Un único nombre puede denotar una variable local o una global (o un argumento formal de una función, el cual es una forma particular de una variable local):
<pre>   var ::= nombre
</pre>
<code>nombre</code> denota identificadores, como se definen en <a href="#2.1">&sect;2.1</a>.

<p>Lua asume que las variables son globales, a no ser que sean declaradas explícitamente como locales (véase <a href="#2.4.7">&sect;2.4.7</a>). Las variables locales tienen un ámbito (<em>scope</em>) definido <em>léxicamente</em>: pueden ser accedidas libremente desde dentro de las funciones definidas en su mismo ámbito (véase <a href="#2.6">&sect;2.6</a>).

<p>Antes de la primera asignación el valor de una variable es <b>nil</b>.

<p>Los corchetes se usan para indexar una tabla:
<pre>   var ::= prefixexp '<b>[</b>' exp '<b>]</b>'
</pre>
La primera expresión (<em>prefixexp</em>) debe dar como resultado un valor tabla; la segunda expresión (<em>exp</em>) identifica una entrada específica en esta tabla. La expresión que denota la tabla que es indexada tienen una sintaxis restringida; véase <a href="#2.5">&sect;2.5</a> para más detalles.

<p>La sintaxis <code>var.nombre</code> es otra manera de expresar
<code>var["nombre"]</code> y se usa para denotar campos de tablas:
<pre>   var ::= prefixexp '<b>.</b>' nombre
</pre>

<p>La manera en qué se accede a las variables globales y a los campos de las tablas puede ser cambiada mediante metatablas. Un acceso a la variable indexada <code>t[i]</code> equivale a una llamada a <code>gettable_event(t,i)</code> (véase <a href="#2.8">&sect;2.8</a> para una completa descripción de la función <code>gettable_event</code>. Esta función no está definida ni es invocable desde Lua. Se usa aquí sólo con propósitos ilustrativos).

<p>Todas las variables globales se almacenan como campos de tablas ordinarias en Lua, denominadas <em>tablas de entorno</em> o simplemente <em>entornos</em> (véase <a href="#2.9">&sect;2.9</a>). Cada función tiene su propia referencia a un entorno, así que todas las variables globales de esta función se refieren a esa tabla de entorno. Cuando se crea una función, ésta hereda el entorno de la función que la creó. Para obtener la tabla de entorno de una función en código Lua, se invoca a <a href="#pdf-getfenv"><code>getfenv</code></a>. Para reemplazarla se llama a <a href="#pdf-setfenv"><code>setfenv</code></a>. (Se pueden manejar los entornos de una función C, pero sólo a través de la biblioteca de depuración; véase <a href="#5.9">&sect;5.9</a>.)

<p>Un acceso a la variable global <code>x</code> equivale a <code>_env.x</code>, que a su vez equivale a
<pre>       gettable_event(_env, "x")
</pre>
donde <code>_env</code> es el entorno de la función que se está ejecutando en ese momento (véase <a href="#2.8">&sect;2.8</a> para una completa descripción de la función <code>gettable_event</code>. Esta función no está definida ni es invocable desde Lua. Igualmente, la variable <code>_env</code> no está definida en Lua. Se usan aquí sólo con propósitos ilustrativos.)

<p><a name="2.4"></a><h2>2.4 - Sentencias</h2>

<p>Lua soporta un conjunto casi convencional de sentencias, similar a los de Pascal o C. Este conjunto incluye la asignación, estructuras de control de flujo, llamadas a funciones, constructores de tablas y declaraciones de variables.

<p><a name="2.4.1"></a><h3>2.4.1 - <em>Chunks</em></h3>

<p>La unidad de ejecución en Lua se denomina <a href="#chunk"><em>chunk</em></a>, el cual es simplemente un conjunto de sentencias que se ejecutan secuencialmente. Cada sentencia puede llevar opcionalmente al final un punto y coma:
<pre>   chunk ::= {sentencia ['<b>;</b>']}
</pre>
No existen sentencias vacías en Lua y por tanto '<code>;;</code>' no es legal.

<p>Lua maneja cada <em>chunk</em> como el cuerpo de una función anónima con un número variable de argumentos (véase <a href="#2.5.9">&sect;2.5.9</a>). Los <em>chunks</em> pueden definir variables locales, recibir argumentos y retornar valores.

<p>Un <em>chunk</em> puede ser almacenado en un fichero o en un <em>string</em> dentro de un programa anfitrión. Cuando se ejecuta un <em>chunk</em> primero se precompila, creándose instrucciones para una máquina virtual, y es entonces cuando el código compilado es ejecutado por un intérprete de la máquina virtual.

<p>Los <em>chunks</em> pueden también estar precompilados en forma binaria; véase el programa <code>luac</code> para más detalles. Las formas fuente y compilada de los programas son intercambiables; Lua detecta automáticamente el tipo de fichero y actúa de manera acorde.


<p><a name="2.4.2"></a><h3>2.4.2 - Bloques</h3>

Un bloque es una lista de sentencias; sintácticamente un bloque es lo mismo que un <em>chunk</em>:
<pre>   bloque ::= chunk
</pre>

<p>Un bloque puede ser delimitado explícitamente para producir una sentencia simple:
<pre>   sentencia ::= <b>do</b> bloque <b>end</b>
</pre>
Los bloques explícitos son útiles para controlar el ámbito de las declaraciones de variable. También se utilizan a veces para añadir sentencias <b>return</b> o <b>break</b> en medio de otro bloque (véase <a href="#2.4.4">&sect;2.4.4</a>).


<p><a name="2.4.3"></a><h3>2.4.3 - La asignación</h3>

<p>Lua permite asignaciones múltiples. Por tanto la sintaxis de una asignación define una lista de variables a la izquierda y una lista de expresiones a la derecha. Los elementos de ambas listas están separados por comas:
<pre>   sentencia ::= varlist '<b>=</b>' explist
   varlist ::= var {'<b>,</b>' var}
   explist ::= exp {'<b>,</b>' exp}
</pre>
Las expresiones se analizan en <a href="#2.5">&sect;2.5</a>.

<p>Antes de una asignación la lista de expresiones se <em>ajusta</em> a la longitud de la lista de variables. Si existen más valores de los necesarios el exceso se descarta. Si existen menos valores de los necesarios la lista se extiende con tantos valores <b>nil</b> como se necesiten. Si la lista de expresiones finaliza con una llamada a una función entonces todos los valores devueltos en la llamada pueden entrar en la lista de valores antes del ajuste (excepto cuando se encierra entre paréntesis; véase <a href="#2.5">&sect;2.5</a>).

<p>La sentencia de asignación primero evalúa todas sus expresiones y sólo después se hace la asignación. Entonces, el código
<pre>       i = 3
       i, b[i] = i+1, 20
</pre>
asigna 20 a <code>b[3]</code>, sin afectar a <code>b[4]</code> debido a que <code>i</code> en <code>b[i]</code> se evalúa (a 3) antes de que se le asigne el valor 4. Similarmente, la línea
<pre>       x, y = y, x
</pre>
intercambia los valores de <code>x</code> e <code>y</code>.

<p>El mecanismo de asignación a las variables globales y a los campos de tablas puede ser modificado mediante metatablas. Una asignación a una variable indexada <code>t[i] = val</code> equivale a <code>settable_event(t,i,val)</code>. (Véase <a href="#2.8">&sect;2.8</a> para una completa descripción de la función <code>settable_event</code>. Esta función no está definida ni es invocable desde Lua. Se usa sólo con propósitos ilustrativos.)

<p>Una asignación a la variable global <code>x = val</code>
equivale a la asignación <code>_env.x = val</code>,
que a su vez equivalen a
<pre>       settable_event(_env, "x", val)
</pre>
donde <code>_env</code> es el entorno de la función que está ejecutándose en ese momento.
(La variable <code>_env</code> no está definida en Lua.
Se utiliza aquí sólo con propósitos ilustrativos.)

<p><a name="2.4.4"></a><h3>2.4.4 - Estructuras de control</h3>
Las estructuras de control <b>if</b>, <b>while</b> y <b>repeat</b> tienen el significado habitual y la sintaxis familiar:



<pre>   sentencia ::= <b>while</b> exp <b>do</b> bloque <b>end</b>
   sentencia ::= <b>repeat</b> bloque <b>until</b> exp
   sentencia ::= <b>if</b> exp <b>then</b> bloque {<b>elseif</b> exp <b>then</b> bloque} [<b>else</b> bloque] <b>end</b>
</pre>
Lua tiene también una sentencia <b>for</b>, en dos formatos (véase <a href="#2.4.5">&sect;2.4.5</a>).

<p>La condición de una expresión de una estructura de control puede retornar cualquier valor. Tanto <b>false</b> como <b>nil</b> se consideran falsos. Todos los valores diferentes de <b>nil</b> y <b>false</b> se consideran verdaderos (en particular, el número 0 y el <em>string</em> vacío son también verdaderos).

<p>En el bucle <b>repeat</b>&ndash;<b>until</b> el bloque interno no acaba en la palabra clave <b>until</b> sino detrás de la condición. De esta manera la condición puede referirse a variables locales declaradas dentro del bloque del bucle.

<p>La orden <b>return</b> se usa para devolver valores desde una función o un <em>chunk</em> (el cual es justamente una función).

Las funciones y los <em>chunks</em> pueden retornar más de un valor, por lo que la sintaxis para <b>return</b> es
<pre>   sentencia ::= <b>return</b> [explist]
</pre>

<p>La orden <b>break</b> se usa para terminar la ejecución de los bucles <b>while</b>, <b>repeat</b> y <b>for</b>, saltando a la sentencia que sigue después del bucle:

<pre>   sentencia ::= <b>break</b>
</pre>
Un <b>break</b> finaliza el bucle más interno que esté activo.

<p>Las órdenes <b>return</b> y <b>break</b> pueden aparecer sólo como <em>última</em> sentencia dentro de un bloque. Si se necesita realmente un <b>return</b> o un <b>break</b> en medio de un bloque se debe usar un bloque más interno explícitamente, como en '<code>do return end</code>' y '<code>do break end</code>', debido a que así <b>return</b> y <b>break</b> son las últimas sentencias en su propio bloque.

<p><a name="2.4.5"></a><h3>2.4.5 - La sentencia for</h3>

<p>La sentencia <b>for</b> tiene dos formas: una numérica y otra genérica.

<p>La forma numérica del bucle <b>for</b> repite un bloque mientras una variable de control sigue una progresión aritmética. Tiene la sintaxis siguiente:
<pre>   sentencia ::= <b>for</b> nombre '<b>=</b>' exp1 '<b>,</b>' exp2 ['<b>,</b>' exp3] <b>do</b> bloque <b>end</b>
</pre>
El <em>bloque</em> se repite para los valores de <em>nombre</em> comenzando en <em>exp1</em> hasta que sobrepasa <em>exp2</em> usando como paso <em>exp3</em>. Más precisamente una sentencia <b>for</b> como
<pre>       for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>bloque</em> end
</pre>
equivale al código:
<pre>       do
         local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
         if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
         while (<em>step</em> &gt; 0 and <em>var</em> &lt;= <em>limit</em>) or (<em>step</em> &lt;= 0 and <em>var</em> &gt;= <em>limit</em>) do
           local v = <em>var</em>
           <em>bloque</em>
           <em>var</em> = <em>var</em> + <em>step</em>
         end
       end
</pre>
Nótese lo siguiente:
<ul>
<li> Todas las expresiones de control se evalúan sólo una vez, antes de que comience el bucle. Deben resultar todas en números. </li><li> <em>var</em>, <em>limit</em> y <em>step</em> son variables invisibles. Los nombres aparecen aquí sólo con propósitos ilustrativos.
</li><li> Si la tercera expresión (el paso) está ausente se utiliza paso 1.
</li><li> Se puede utilizar <b>break</b> para salir del bucle <b>for</b>.
</li><li> La variable de control <code>v</code> es local dentro del bucle; no se puede utilizar su valor después de que finalice el bucle <b>for</b> o después de una salida del mismo con <b>break</b>. Si se necesita el valor de la variable <code>var</code> entonces debe asignarse a otra variable antes del <b>break</b> o de la salida del bucle.
</li></ul>

<p>La sentencia <b>for</b> genérica trabaja con funciones, denominadas <em>iteradores</em>. En cada iteración se invoca a la función iterador que produce un nuevo valor, parándose la iteración cuando el nuevo valor es <b>nil</b>. El bucle <b>for</b> genérico tiene la siguiente sintaxis:
<pre>   sentencia ::= <b>for</b> lista_de_nombres <b>in</b> explist <b>do</b> bloque <b>end</b>
   lista_de_nombres ::= nombre {'<b>,</b>' nombre}
</pre>
Una sentencia <b>for</b> como
<pre>       for <em>var_1</em>, ..., <em>var_n</em> in <em>explist</em> do <em>bloque</em> end
</pre>
equivale al código:
<pre>       do
         local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
         while true do
           local <em>var_1</em>, ... , <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
           <em>var</em> = <em>var_1</em>
           if <em>var</em> == nil then break end
           <em>bloque</em>
         end
       end
</pre>
Nótese lo siguiente:
<ul>
<li> <em>explist</em> se evalúa sólo una vez. Sus resultados son una función <em>iterador</em>, un <em>estado</em> y un valor inicial para la primera <em>variable iteradora</em>.
</li><li> <em>f</em>, <em>s</em> y <em>var</em> son variables invisibles. Los nombres que aquí aparecen son sólo ilustrativos.
</li><li> Se puede usar una orden <b>break</b> para salir del bucle <b>for</b>.
</li><li> Las variables de control del bucle <em>var_i</em> son locales en el bucle; no se pueden usar sus valores después de que acabe el bucle <b>for</b>. Si se necesitan sus valores se deben asignar a otras variables antes de que se salga del bucle (normalmente o con un <b>break</b>).
</li></ul>

<p><a name="2.4.6"></a><h3>2.4.6 - Sentencias de llamadas a función</h3>
Para evitar posibles efectos laterales, las llamadas a función pueden ser realizadas como sentencias:
<pre>   sentencia ::= llamada_a_func
</pre>
En ese caso todos los valores retornados se descartan. Las llamadas a función están explicadas en <a href="#2.5.8">&sect;2.5.8</a>.

<p><a name="2.4.7"></a><h3>2.4.7 - Declaraciones locales</h3>
Las variables locales pueden ser declaradas en cualquier lugar dentro de un bloque. Esas declaraciones pueden incluir una asignación inicial:
<pre>   sentencia ::= <b>local</b> lista_de_nombres ['<b>=</b>' explist]
</pre>
Si está presente, una asignación inicial tiene la misma semántica que una asignación múltiple (véase <a href="#2.4.3">&sect;2.4.3</a>). En otro caso todas las variables son inicializadas con <b>nil</b>.

<p>Un <em>chunk</em> es también un bloque (véase <a href="#2.4.1">&sect;2.4.1</a>), así que las variables locales pueden ser declaradas en un <em>chunk</em> fuera de cualquier bloque explícito. El ámbito de esas variables se extiende hasta el final del <em>chunk</em>.

<p>Las reglas de visibilidad para las variables locales se exponen en <a href="#2.6">&sect;2.6</a>.

<p><a name="2.5"></a><h2>2.5 - Expresiones</h2>

<p>
Las expresiones básicas en Lua son las siguientes:
<pre>   exp ::= prefixexp
   exp ::= <b>nil</b>  |  <b>false</b>  |  <b>true</b>
   exp ::= Número
   exp ::= String
   exp ::= func
   exp ::= constructor_de_tabla
   exp ::= '<b>...</b>'
   exp ::= exp operador_binario exp
   exp ::= operador_unario exp
   prefixexp ::= var  |  llamada_a_func  |  '<b>(</b>' exp '<b>)</b>'
</pre>

<p>Los números y los <em>string</em> literales se explican en <a href="#2.1">&sect;2.1</a>; las variables se explican en <a href="#2.3">&sect;2.3</a>; la definición de funciones se explica en <a href="#2.5.9">&sect;2.5.9</a>; las llamadas a función se explican en <a href="#2.5.8">&sect;2.5.8</a>; los constructores de tablas se explican en <a href="#2.5.7">&sect;2.5.7</a>. Las expresiones <em>vararg</em> (que indican un número variable de argumentos en una función), denotadas mediante tres puntos ('<code>...</code>'), pueden ser usadas directamente sólo cuando están dentro de las funciones con <em>vararg</em>; se explican en <a href="#2.5.9">&sect;2.5.9</a>.


<p>Los operadores binarios comprenden los operadores aritméticos (véase <a href="#2.5.1">&sect;2.5.1</a>), los operadores relacionales (véase <a href="#2.5.2">&sect;2.5.2</a>) y los operadores lógicos (véase <a href="#2.5.3">&sect;2.5.3</a>). Los operadores unarios compenden el menos unario (véase <a href="#2.5.1">&sect;2.5.1</a>), el <b>not</b> unario (véase <a href="#2.5.3">&sect;2.5.3</a>) y el <em>operador de longitud</em> unario (véase <a href="#2.5.5">&sect;2.5.5</a>).

<p>Tanto las llamadas a función como las expresiones <em>vararg</em> pueden resultar en valores múltiples. Si la expresión se usa como una sentencia (véase <a href="#2.4.6">&sect;2.4.6</a>) (sólo posible con llamadas a función), entonces su lista de valores retornados se ajusta a cero elementos, descartando todos los valores retornados. 
Si la expresión se usa como el último (o único) elemento de una lista de expresiones entonces no se realiza ningún ajuste (a no ser que la llamada se encierre entre paréntesis). En todos los demás contextos Lua ajusta el resultado de la lista a un solo elemento, descartando todos los valores excepto el primero.

<p>He aquí varios ejemplos:
<pre>       f()              -- ajustado a 0 resultados
       g(f(), x)        -- f() es ajustado a 1 resultado
       g(x, f())        -- g toma x y todos los valores devueltos por f()
       a,b,c = f(), x   -- f() se ajusta a 1 resultado (c toma el valor nil)
       a,b = ...        -- a toma el primer argumento vararg, b toma
                        -- el segundo (a y b pueden ser nil si no existen los
                        -- correspondientes argumentos vararg)
       a,b,c = x, f()   -- f() se ajusta a 2 resultados
       a,b,c = f()      -- f() se ajusta a 3 resultados
       return f()       -- retorna todos los valores devueltos por f()
       return ...       -- retorna todos los argumentos vararg recibidos
       return x,y,f()   -- retorna x, y, y todos los valores devueltos por f()
       {f()}            -- crea una lista con todos los valores retornados por f()
       {...}            -- crea una lista con todos los argumentos vararg
       {f(), nil}       -- f() se ajusta a 1 resultado
</pre>

<p>Una expresión encerrada en paréntesis siempre resulta en un único valor. Entonces, <code>(f(x,y,z))</code> siempre es un valor único, incluso si <code>f</code> retorna varios valores. (El valor de <code>(f(x,y,z))</code> es el primer valor retornado por <code>f</code> o <b>nil</b> si <code>f</code> no retorna ningún valor).

<p><a name="2.5.1"></a><h3>2.5.1 - Operadores aritméticos</h3>
Lua tiene los operadores aritméticos comunes: los binarios <code>+</code> (adición), <code>-</code> (substracción), <code>*</code> (multiplicación), <code>/</code> (división), <code>%</code> (módulo) y <code>^</code> (exponenciación); y el unario <code>-</code> (negación). Si los operandos son números o <em>strings</em> que se convierten a números (véase <a href="#2.2.1">&sect;2.2.1</a>), entonces todas las operaciones tienen el significado corriente. La exponenciación trabaja con cualquier exponente. Por ejemplo, <code>x^(-0.5)</code> calcula la inversa de la raiz cuadrada de <code>x</code>. El módulo se define como
<pre>       a % b == a - math.floor(a/b)*b
</pre>
Esto es, es el resto de la división que redondea el cociente hacia menos infinito.

<p><a name="2.5.2"></a><h3>2.5.2 - Operadores relacionales</h3>
Los operadores relacionales en Lua son
<pre>       ==    ~=    &lt;     &gt;     &lt;=    &gt;=
</pre>
Devuelven siempre un resultado <b>false</b> o <b>true</b>.

<p>La igualdad (<code>==</code>) primero compara el tipo de los operandos. Si son diferentes entonces el resultado es <b>false</b>. En otro caso se comparan los valores de los operandos. Los números y los <em>strings</em> se comparan de la manera usual. Los objetos (tablas, <em>userdata</em>, procesos y funciones) se comparan por <em>referencia</em>: dos objetos se consideran iguales sólo si son el <em>mismo</em> objeto. Cada vez que se crea un nuevo objeto (una tabla, <em>userdata</em>, proceso o función) este nuevo objeto es diferente de todos los demás objetos preexistentes.

<p>Se puede cambiar la manera en que Lua compara tablas y <em>userdata</em> usando el metamétodo "eq" (véase <a href="#2.8">&sect;2.8</a>).

<p>Las reglas de conversión de <a href="#2.2.1">&sect;2.2.1</a> <em>no</em> se aplican en las comparaciones de igualdad. De este modo <code>"0"==0</code> es <b>false</b>, y <code>t[0]</code> y <code>t["0"]</code> denotan diferentes entradas en una tabla.

<p>El operador <code>~=</code> es exactamente la negación de la igualdad (<code>==</code>).

<p>El orden de los operadores funciona de la siguiente manera. Si ambos argumentos son números entonces se comparan como tales. En otro caso, si ambos argumentos son <em>strings</em> sus valores se comparan de acuerdo al sistema local. En otro caso, Lua trata de usar los metamétodos "lt" o "le" (véase <a href="#2.8">&sect;2.8</a>).

<p><a name="2.5.3"></a><h3>2.5.3 - Operadores lógicos</h3>

Los operadores lógicos en Lua son <b>and</b>, <b>or</b> y <b>not</b>.
Como las estructuras de control (véase <a href="#2.4.4">&sect;2.4.4</a>) todos los operadores lógicos consideran <b>false</b> y <b>nil</b> como falso y todo lo demás como verdadero.


<p>El operador negación <b>not</b> siempre retorna <b>false</b> o <b>true</b>. El operador conjunción <b>and</b> retorna su primer operando si su valor es <b>false</b> o <b>nil</b>; en caso contrario <b>and</b> retorna su segundo operando. El operador disyunción <b>or</b> retorna su primer operando si su valor es diferente de <b>nil</b> y <b>false</b>; en caso contrario <b>or</b> retorna su segundo argumento. Tanto <b>and</b> como <b>or</b> usan evaluación de <em>cortocircuito</em>; esto es, su segundo operando se evalúa sólo si es necesario. He aquí varios ejemplos:
<pre>       10 or 20            --&gt; 10
       10 or error()       --&gt; 10
       nil or "a"          --&gt; "a"
       nil and 10          --&gt; nil
       false and error()   --&gt; false
       false and nil       --&gt; false
       false or nil        --&gt; nil
       10 and 20           --&gt; 20
</pre>
(En este manual '<code>--&gt;</code>' indica el resultado de la expresión precedente.)

<p><a name="2.5.4"></a><h3>2.5.4 - Concatenación</h3>
El operador de concatenación de <em>strings</em> en Lua se denota mediante dos puntos seguidos ('<code>..</code>'). Si ambos operandos son <em>strings</em> o números entonces se convierten a <em>strings</em> mediante las reglas mencionadas en <a href="#2.2.1">&sect;2.2.1</a>. En otro caso se invoca al metamétodo "concat" (véase <a href="#2.8">&sect;2.8</a>).

<p><a name="2.5.5"></a><h3>2.5.5 - El operador longitud</h3>

<p>El operador longitud se denota mediante <code>#</code>.  La longitud de un <em>string</em> es su número de bytes (significado normal de la longitud de un <em>string</em> cuando cada carácter ocupa un byte).

<p>La longitud de una tabla <code>t</code> se define como un índice entero <code>n</code> tal que <code>t[n]</code> no es <b>nil</b> y <code>t[n+1]</code> es <b>nil</b>; además, si <code>t[1]</code> es <b>nil</b> entonces <code>n</code> puede ser cero. Para un <em>array</em> regular, con valores no <b>nil</b> desde 1 hasta un <code>n</code> dado, la longitud es exactamente <code>n</code>, el índice es su último valor. Si el <em>array</em> tiene "agujeros" (esto es, valores <b>nil</b> entre otros valores que no lo son), entonces <code>#t</code> puede ser cualquiera de los índices que preceden a un valor <b>nil</b> (esto es, Lua puede considerar ese valor <b>nil</b> como el final del <em>array</em>).

<p><a name="2.5.6"></a><h3>2.5.6 - Precedencia de los operadores</h3>
La precedencia de los operadores en Lua sigue lo expuesto en la tabla siguiente de menor a mayor prioridad:
<pre>       or
       and
       &lt;     &gt;     &lt;=    &gt;=    ~=    ==
       ..
       +     -
       *     /     %
       not   #     - (unario)
       ^
</pre>
Como es usual, se pueden usar paréntesis para cambiar la precedencia en una expresión. Los operadores de concatenación ('<code>..</code>') y de exponenciación ('<code>^</code>') son asociativos por la derecha. Todos los demás operadores son asociativos por la izquierda.

<p><a name="2.5.7"></a><h3>2.5.7 - Constructores de tabla</h3>
Los constructores de tabla son expresiones que crean tablas. Cada vez que se evalúa un constructor se crea una nueva tabla. Los constructores pueden ser usados para crear tablas vacías o para crear tablas e inicializar alguno de sus campos. La sintaxis general para esos constructores es
<pre>   constructor_de_tabla ::= '<b>{</b>' [lista_de_campos] '<b>}</b>'
   lista_de_campos ::= campo {separador_de_campos campo} [separador_de_campos]
   campo ::= '<b>[</b>' exp '<b>]</b>' '<b>=</b>' exp  |  nombre '<b>=</b>' exp  |  exp
   separador_de_campos ::= '<b>,</b>'  |  '<b>;</b>'
</pre>

<p>Cada campo de la forma <code>[exp1] = exp2</code> añade una entrada a la nueva tabla con la clave <code>exp1</code> y con el valor <code>exp2</code>. Un campo de la forma <code>nombre = exp</code> equivale a <code>["nombre"] = exp</code>. Finalmente, campos de la forma <code>exp</code> son equivalentes a <code>[i] = exp</code>, donde <code>i</code> son números enteros consecutivos, comenzando con 1. Los campos en el otro formato no afectan este contador. Por ejemplo,
<pre>       a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre>
equivale a
<pre>       do
         local t = {}
         t[f(1)] = g
         t[1] = "x"         -- 1ª exp
         t[2] = "y"         -- 2ª exp
         t.x = 1            -- t["x"] = 1
         t[3] = f(x)        -- 3ª exp
         t[30] = 23
         t[4] = 45          -- 4ª exp
         a = t
       end
</pre>

<p>Si el último campo en la lista tiene la forma <code>exp</code> y la expresión es una llamada a función o una expresión <em>vararg</em>, entonces todos los valores retornados por esta expresión entran en la lista consecutivamente (véase <a href="#2.5.8">&sect;2.5.8</a>). Para evitar esto debe encerrarse la llamada a la función (o la expresión <em>vararg</em>) entre paréntesis (véase <a href="#2.5">&sect;2.5</a>).

<p>La lista de campos puede tener un separador opcional al final, una conveniencia para código fuente generado de manera automática.

<p><a name="2.5.8"></a><h3>2.5.8 - Llamadas a función</h3>
Una llamada a una función tiene en Lua la siguiente sintaxis:
<pre>   llamada_a_func ::= prefixexp argumentos
</pre>
En una llamada a función, se evalúan primero <em>prefixexp</em> y los <em>argumentos</em>.  Si el valor de <em>prefixexp</em> es del tipo <em>function</em>, entonces se invoca a esta función con los argumentos dados. En caso contrario se invoca el metamétodo "call", pasando como primer argumento el valor de <em>prefixexp</em> seguido por los argumentos originales de la llamada (véase <a href="#2.8">&sect;2.8</a>).

<p>La forma
<pre>   llamada_a_func ::= prefixexp '<b>:</b>' nombre argumentos
</pre>
puede ser usada para invocar "métodos".
Una llamada <code>v:nombre(...)</code>
es otra manera de expresar <code>v.nombre(v,...)</code>,
excepto que <code>v</code> se evalúa sólo una vez.

<p>Los argumentos tienen la siguiente sintaxis:
<pre>   argumentos ::= '<b>(</b>' [explist] '<b>)</b>'
   argumentos ::= constructor_de_tabla
   argumentos ::= String
</pre>
Todos los argumentos de la expresión se evalúan antes de la llamada. Un llamada de la forma <code>f{...}</code> es otra manera de expresar <code>f({...})</code>; esto es, la lista de argumentos es una nueva tabla simple. Una llamada de la forma <code>f'...'</code> (o <code>f"..."</code> o <code>f[[...]]</code>) es otra manera de expresar <code>f('...')</code>; esto es, la lista de argumentos es un <em>string</em> literal simple.

<p>Como excepción a la sintaxis de formato libre de Lua, no se puede poner una rotura de línea antes de '<code>(</code>' en una llamada a función. Esta restricción evita algunas ambigüedades en el lenguaje. Si se escribe
<pre>       a = f
       (g).x(a)
</pre>
Lua podría ententerlo como una sentencia simple, <code>a = f(g).x(a)</code>. Entonces, si se desean dos sentencias se debe añadir un punto y coma entre ellas. Si realmente se desea llamar a <code>f</code>, se debe eliminar la rotura de línea antes de <code>(g)</code>.

<p>Una llamada de la forma <code>return</code> <em>llamada_a_func</em> se denomina una <em>llamada de cola</em>. Lua implementa <em>llamadas de cola correctas</em> (o <em>recursión de cola correcta</em>): en una llamada de cola la función invocada reutiliza la entrada en la pila de la función que la está llamando. Por tanto no existe límite en el número de llamadas de cola anidadas que un programa puede ejecutar. Sin embargo una llamada de cola borra cualquier información de depuración relativa a la función invocante. Nótese que una llamada de cola sólo ocurre con una sintaxis particular donde el <b>return</b> tiene una llamada simple a función como argumento; esta sintásis hace que la función invocante devuelva exactamente el retorno de la función invocada. Según esto ninguno de los siguientes ejemplos son llamadas de cola:
<pre>       return (f(x))        -- resultados ajustados a 1
       return 2 * f(x)
       return x, f(x)       -- resultados adicionales
       f(x); return         -- resultados descartados
       return x or f(x)     -- resultados ajustados a 1
</pre>

<p><a name="2.5.9"></a><h3>2.5.9 - Definición de funciones</h3>

<p>La sintaxis para la definición de funciones es
<pre>   func ::= <b>function</b> cuerpo_de_func
   cuerpo_de_func ::= '<b>(</b>' [lista_de_argumentos] '<b>)</b>' bloque <b>end</b>
</pre>

<p>La siguiente forma simplifica la definición de funciones:
<pre>   sentencia ::= <b>function</b> nombre_de_func cuerpo_de_func
   sentencia ::= <b>local</b> <b>function</b> nombre cuerpo_de_func
   nombre_de_func ::= nombre {'<b>.</b>' nombre} ['<b>:</b>' nombre]
</pre>
La sentencia
<pre>       function f () <em>cuerpo_de_función</em> end
</pre>
se traduce en
<pre>       f = function () <em>cuerpo_de_función</em> end
</pre>
La sentencia
<pre>       function t.a.b.c.f () <em>cuerpo_de_función</em> end
</pre>
se traduce en
<pre>       t.a.b.c.f = function () <em>cuerpo_de_función</em> end
</pre>
La sentencia
<pre>       local function f () <em>cuerpo_de_función</em> end
</pre>
se traduce en
<pre>       local f; f = function () <em>cuerpo_de_función</em> end
</pre>
<em>no</em> en:
<pre>       local f = function () <em>cuerpo_de_función</em> end
</pre>
(Esto sólo entraña diferencias cuando el cuerpo de la
función contiene referencias a <code>f</code>.)

<p>Una definición de función es una expresión ejecutable, cuyo valor tiene el tipo <em>function</em>. Cuando Lua precompila un <em>chunk</em> todos sus cuerpos de función son también precompilados. Entonces cuando Lua ejecuta la definición de función, la misma es <em>instanciada</em> (o <em>cerrada</em>). Esta instancia de función (o <em>closure</em>) es el valor final de la expresión. Diferentes instancias de la misma función pueden referirse a diferentes variables locales externas y pueden tener diferentes tablas de entorno.

<p>Los argumentos formales de una función actúan como variables locales que son inicializadas con los valores actuales de los argumentos:
<pre>   lista_de_argumentos ::= lista_de_nombres ['<b>,</b>' '<b>...</b>']  |  '<b>...</b>'
</pre>
Cuando se invoca una función, la lista de argumentos actuales se ajusta a la longitud de la lista de argumentos formales, a no ser que la función sea de tipo <em>vararg</em>, lo que se indica por tres puntos ('<code>...</code>') al final de la lista de argumentos formales. Una función <em>vararg</em> no ajusta su lista de argumentos; en su lugar recolecta todos los argumentos actuales extra y se los pasa a la función a través de una <em>expresión vararg</em>, lo que también se indica por medio de tres puntos. El valor de esta expresión es una lista de todos los argumentos actuales extra, similar a una función con resultados múltiples. Si la expresión <em>vararg</em> se usa en el interior de otra expresión o en el medio de una lista de expresiones, entonces su retorno se ajusta a un sólo elemento. Si la expresión es usada como el último elemento de una lista de expresiones entonces no se hace ningún ajuste (a no ser que la llamada se realice entre paréntesis).

<p>Como ejemplo, consideremos las siguientes definiciones:
<pre>       function f(a, b) end
       function g(a, b, ...) end
       function r() return 1,2,3 end
</pre>
Entonces tenemos la siguiente correspondencia de los argumentos actuales a los formales y a la expresión <em>vararg</em>:
<pre>       LLAMADA          ARGUMENTOS

       f(3)             a=3, b=nil
       f(3, 4)          a=3, b=4
       f(3, 4, 5)       a=3, b=4
       f(r(), 10)       a=1, b=10
       f(r())           a=1, b=2

       g(3)             a=3, b=nil, ... --&gt;  (nada)
       g(3, 4)          a=3, b=4,   ... --&gt;  (nada)
       g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
       g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>Los resultados se devuelven usando la sentencia <b>return</b> (véase <a href="#2.4.4">&sect;2.4.4</a>). Si el flujo del programa alcanza el final de una función sin encontrar una sentencia <b>return</b> entonces la función retorna sin resultados.

<p>La sintaxis <em>con dos puntos</em> ('<code>:</code>') se usa para definir <em>métodos</em>, esto es, funciones que tienen un argumento extra denominado <code>self</code>. Entonces la sentencia
<pre>       function t.a.b.c:f (<em>params</em>) <em>cuerpo_de_función</em> end
</pre>
es otra manera de expresar
<pre>       t.a.b.c.f = function (self, <em>params</em>) <em>cuerpo_de_función</em> end
</pre>

<p><a name="2.6"></a><h2>2.6 - Reglas de visibilidad</h2>


<p>Lua es un lenguaje con ámbito léxico. El ámbito de las variables comienza en la primera sentencia <em>después</em> de su declaración y termina al final del bloque más interno que incluya la declaración. Consideremos el siguiente ejemplo:
<pre>       x = 10                -- variable global
       do                    -- nuevo bloque
         local x = x         -- nueva 'x', con valor 10
         print(x)            --&gt; 10
         x = x+1
         do                  -- otro bloque
           local x = x+1     -- otra 'x'
           print(x)          --&gt; 12
         end
         print(x)            --&gt; 11
       end
       print(x)              --&gt; 10  (el valor de la variable global)
</pre>

<p>Tengase presente que en una declaración como <code>local x = x</code>, la nueva <code>x</code> que está siendo declarada no tiene ámbito todavía, y la segunda <code>x</code> se refiere a la variable externa.

<p>Debido a las reglas de ámbito léxico, las variables locales pueden ser accedidas por funciones definidas en el interior de su propio ámbito. Una variable local usada en una función interna se denomina <a href="#upvalue"><em>upvalue</em></a> o <em>variable local externa</em> en el interior de la función.

<p>Nótese que cada ejecución de una sentencia <b>local</b>
define nuevas variables locales. Considérese el siguiente ejemplo:
<pre>       a = {}
       local x = 20
       for i=1,10 do
         local y = 0
         a[i] = function () y=y+1; return x+y end
       end
</pre>
El bucle crea diez <em>closures</em> (esto es, diez instancias de una función anónima). Cada uno de estas instancias usa una variable <code>y</code> diferente, mientras que todas ellas comparten la misma <code>x</code>.

<p><a name="2.7"></a><h2>2.7 - Manejo de errores</h2>

<p>Debido a que Lua es un lenguaje de extensión embebido, todas las acciones de Lua comienzan con código C en el programa anfitrión llamando a una función de la biblioteca de Lua (véase <a href="#lua_pcall"><code>lua_pcall</code></a>). Cada vez que ocurra un error durante la compilación o ejecución de Lua, el control retorna a C, que puede tomar las medidas apropiadas (tales como imprimir un mensaje de error).

<p>Se puede generar (o activar) explícitamente en Lua un error invocando la función <a href="#pdf-error"><code>error</code></a>. Si se necesita capturar errores en Lua se puede usar la función <a href="#pdf-pcall"><code>pcall</code></a>.

<p><a name="2.8"></a><h2>2.8 - Metatablas</h2>

<p>Cada valor en Lua puede tener una <em>metatabla</em>. Ésta es una tabla ordinaria de Lua que define el comportamiento del valor original para ciertas operaciones especiales. Se pueden cambiar varios aspectos del comportamiento de las operaciones realizadas sobre un valor estableciendo campos específicos en su metatabla. Por ejemplo, cuando un valor no numérico es un operando de una adición Lua busca una función en el campo <code>"__add"</code> de su metatabla. Si se encuentra una, entonces se invoca esa función para realizar la adición.

<p>Llamamos <em>eventos</em> a los campos de una metatabla y a los valores los denominamos <em>metamétodos</em>. En el ejemplo anterior el evento es <code>"add"</code> mientras que el metamétodo es la función que realiza la adición.

<p>Se puede solicitar la metatabla de cualquier valor a través de la función <a href="#pdf-getmetatable"><code>getmetatable</code></a>.

<p>Se puede reemplazar la metatabla de una tabla a través de la función <a href="#pdf-setmetatable"><code>setmetatable</code></a>. No se puede cambiar la metatabla de otros tipos de datos desde Lua (excepto usando la biblioteca de depuración); se debe usar la API de C para ello.

<p>Las tablas y los <em>userdata</em> completos tienen metatablas individuales (aunque varias tablas y <em>userdata</em> pueden compartir sus metatablas); los valores de los otros tipos comparten una única metatabla por tipo. Por tanto, existe una única metatabla para todos los números, otra para todos los <em>strings</em>, etc.

<p>Una metatabla puede controlar cómo se comporta un objeto en las operaciones aritméticas, en las comparaciones de orden, en la concatenación, en la operación longitud y en el indexado. Una metatabla puede también definir una función que será invocada cuando se libera memoria ocupada (<em>garbage collection</em>) por <em>userdata</em>. A cada una de esas operaciones Lua le asocia una clave específica denominada <em>evento</em>. Cuando Lua realiza una de esas operaciones con un valor, comprueba si éste tiene una metatabla con el correspondiente evento. Si es así, el valor asociado con esa clave (el <em>metamétodo</em>) controla cómo realiza Lua la operación.

<p>Las metatablas controlan las operaciones listadas a continuación. Cada operación se identifica por su correspondiente nombre. La clave asociada a cada operación es un <em>string</em> con su nombre prefijado con dos subrayados, '<code>__</code>'; por ejemplo, la clave para la operación "add" es el <em>string</em> <code>"__add"</code>. La semántica de esas operaciones está mejor expuesta a través de una función Lua que describe cómo ejecuta el intérprete la operación.

<p>El código Lua mostrado aquí es sólo ilustrativo; el comportamiento real está codificado internamente en el intérprete y es mucho más eficiente que esta simulación. Todas las funciones usadas en estas descripciones (<a href="#pdf-rawget"><code>rawget</code></a>, <a href="#pdf-tonumber"><code>tonumber</code></a>, etc.) están descritas en <a href="#5.1">&sect;5.1</a>. En particular, para recuperar el metamétodo de un objeto dado, usamos la expresión <pre>       metatable(objeto)[evento]
</pre>
Esto puede también ser expresado mediante
<pre>       rawget(getmetatable(objeto) or {}, evento)
</pre>
Por tanto, el acceso a un metamétodo no invoca otros metamétodos, y el acceso a los objetos sin metatablas no falla (simplemente devuelve <b>nil</b>).

<p><ul>
<li><b>"add":</b>
La operación <code>+</code>.

<p>La función <code>getbinhandler</code> que aparece más abajo define cómo escoge Lua un manejador de la operación binaria.  Primero Lua prueba el primer operando. Si su tipo no define un manejador para la operación entonces Lua lo intenta con el segundo operando.
<pre> function getbinhandler (op1, op2, evento)
   return metatable(op1)[evento] or metatable(op2)[evento]
 end
</pre>
Usando esta función el comportamiento del código <code>op1 + op2</code> es
<pre> function add_event (op1, op2)
   local o1, o2 = tonumber(op1), tonumber(op2)
   if o1 and o2 then  -- ¿son numéricos ambos operandos?
     return o1 + o2   -- '+' aquí es la primitiva 'add'
   else  -- al menos uno de los operandos es no numérico
     local h = getbinhandler(op1, op2, "__add")
     if h then
       -- invoca el manejador de ambos operandos
       return (h(op1, op2))
     else  -- no existe un manejador disponible: comportamiento por defecto
       error(&middot;&middot;&middot;)
     end
   end
 end
</pre>

<p></li><li><b>"sub":</b>
La operación <code>-</code>.
El comportamiento es similar a la operación "add".

<p></li><li><b>"mul":</b>
La operación <code>*</code>.
El comportamiento es similar a la operación "add".

<p></li><li><b>"div":</b>
La operación <code>/</code>.
El comportamiento es similar a la operación "add".

<p></li><li><b>"mod":</b>
La operación <code>%</code>.
El comportamiento es similar a la operación "add", usando <code>o1 - floor(o1/o2)*o2</code> como operación primitiva.

<p></li><li><b>"pow":</b>
La operación <code>^</code> (exponenciación).
El comportamiento es similar a la operación "add", con la función <code>pow</code> (de la biblioteca matemática de C) como operación primitiva.

<p></li><li><b>"unm":</b>
La operación <code>-</code> unaria.
<pre> function unm_event (op)
   local o = tonumber(op)
   if o then  -- ¿es numérico el operando?
     return -o  -- '-' aquí es la función primitiva 'unm'
   else  -- el operando no es numérico.
     -- intentar obtener un manejador para el operando
     local h = metatable(op).__unm
     if h then
       -- invocar el manejador con el operando
       return (h(op))
     else  -- no hay manejador disponible: comportamiento por defecto
       error(&middot;&middot;&middot;)
     end
   end
 end
</pre>

<p></li><li><b>"concat":</b>
La operación <code>..</code> (concatenación).
<pre> function concat_event (op1, op2)
   if (type(op1) == "string" or type(op1) == "number") and
      (type(op2) == "string" or type(op2) == "number") then
     return op1 .. op2  -- concatenación primitiva de strings
   else
     local h = getbinhandler(op1, op2, "__concat")
     if h then
       return (h(op1, op2))
     else
       error(&middot;&middot;&middot;)
     end
   end
 end
</pre>

<p></li><li><b>"len":</b>
La operación <code>#</code>.
<pre> function len_event (op)
   if type(op) == "string" then
     return strlen(op)         -- longitud primitiva de string
   elseif type(op) == "table" then
     return #op                -- longitud primitiva de tabla
   else
     local h = metatable(op).__len
     if h then
       -- invocar el manejador con el operando
       return (h(op))
     else  -- no hay manejador disponible: comportamiento por defecto
       error(&middot;&middot;&middot;)
     end
   end
 end
</pre>
Véase <a href="#2.5.5">&sect;2.5.5</a> para una descripción de la longitud de una tabla.

<p></li><li><b>"eq":</b>
La operación <code>==</code>.
La función <code>getcomphandler</code> define cómo elige Lua un metamétodo para el operador de comparación. Se selecciona un metamétodo cuando ambos objetos que son comparados tienen el mismo tipo y el mismo metamétodo para la operación dada.
<pre> function getcomphandler (op1, op2, evento)
   if type(op1) ~= type(op2) then return nil end
   local mm1 = metatable(op1)[evento]
   local mm2 = metatable(op2)[evento]
   if mm1 == mm2 then return mm1 else return nil end
 end
</pre>
El evento "eq" se define así:
<pre> function eq_event (op1, op2)
   if type(op1) ~= type(op2) then  -- ¿diferentes tipos?
     return false   -- diferentes objetos
   end
   if op1 == op2 then   -- ¿iguales primitivas?
     return true   -- los objetos son iguales
   end
   -- probar un metamétodo
   local h = getcomphandler(op1, op2, "__eq")
   if h then
     return (h(op1, op2))
   else
     return false
   end
 end
</pre>
<code>a ~= b</code> equivale a <code>not (a == b)</code>.

<p></li><li><b>"lt":</b>
La operación <code>&lt;</code>.
<pre> function lt_event (op1, op2)
   if type(op1) == "number" and type(op2) == "number" then
     return op1 &lt; op2   -- comparación numérica
   elseif type(op1) == "string" and type(op2) == "string" then
     return op1 &lt; op2   -- comparación lexicográfica 
   else
     local h = getcomphandler(op1, op2, "__lt")
     if h then
       return (h(op1, op2))
     else
       error(&middot;&middot;&middot;);
     end
   end
 end
</pre>
<code>a &gt; b</code> equivale a <code>b &lt; a</code>.

<p></li><li><b>"le":</b>
La operación <code>&lt;=</code>.
<pre> function le_event (op1, op2)
   if type(op1) == "number" and type(op2) == "number" then
     return op1 &lt;= op2   -- comparación numérica
   elseif type(op1) == "string" and type(op2) == "string" then
     return op1 &lt;= op2   -- comparación lexicográfica
   else
     local h = getcomphandler(op1, op2, "__le")
     if h then
       return h(op1, op2)
     else
       h = getcomphandler(op1, op2, "__lt")
       if h then
         return not h(op2, op1)
       else
         error(&middot;&middot;&middot;);
       end
     end
   end
 end
</pre>
<code>a &gt;= b</code> equivale a <code>b &lt;= a</code>. Téngase presente que en ausencia de un metamétodo "le" Lua intenta usar el de "lt", asumiendo que <code>a &lt;= b</code> equivale a <code>not (b &lt; a)</code>.

<p></li><li><b>"index":</b>
El acceso indexado <code>tabla[clave]</code>.
<pre> function gettable_event (tabla, clave)
   local h
   if type(tabla) == "table" then
     local v = rawget(tabla, clave)
     if v ~= nil then return v end
     h = metatable(tabla).__index
     if h == nil then return nil end
   else
     h = metatable(tabla).__index
     if h == nil then
       error(&middot;&middot;&middot;);
     end
   end
   if type(h) == "function" then
     return (h(tabla, clave))  -- invocar el manejador
   else return h[clave]        -- o repetir la operación con él
   end
 end
</pre>

<p></li><li><b>"newindex":</b>
La asignación indexada <code>tabla[clave] = valor</code>.
<pre> function settable_event (tabla, clave, valor)
   local h
   if type(tabla) == "table" then
     local v = rawget(tabla, clave)
     if v ~= nil then rawset(tabla, clave, valor); return end
     h = metatable(tabla).__newindex
     if h == nil then rawset(tabla, clave, valor); return end
   else
     h = metatable(tabla).__newindex
     if h == nil then
       error(&middot;&middot;&middot;);
     end
   end
   if type(h) == "function" then
     h(tabla, clave, valor)    -- invoca el manejador
   else h[clave] = valor       -- o repite la operación con él
   end
 end
</pre>

<p></li><li><b>"call":</b>
invocada cuando Lua llama a un valor.
<pre> function function_event (func, ...)
   if type(func) == "function" then
     return func(...)   -- llamada primitiva
   else
     local h = metatable(func).__call
     if h then
       return h(func, ...)
     else
       error(&middot;&middot;&middot;)
     end
   end
 end
</pre>

<p></li></ul>

<p><a name="2.9"></a><h2>2.9 - Entornos</h2>

<p>Además de metatablas, los objetos de tipo proceso, las funciones y los <em>userdata</em> tienen otra tabla asociada, denominada <em>entorno</em>. Como las metatablas los entornos son tablas normales y varios objetos pueden compartir el mismo entorno.

<p>Los entornos asociados con <em>userdata</em> no tienen significado en Lua. Es sólo una característica para los programadores asociar una tabla con <em>userdata</em>.

<p>Los entornos asociados con procesos se denominan <em>entornos globales</em>. Son usados como entornos por defecto para los procesos y para las funciones no anidadas creadas por el proceso (a través de <a href="#pdf-loadfile"><code>loadfile</code></a>, <a href="#pdf-loadstring"><code>loadstring</code></a> o <a href="#pdf-load"><code>load</code></a>) y pueden ser accedidas directamente por el código en C (véase <a href="#3.3">&sect;3.3</a>).

<p>Los entornos asociados con funciones C pueden ser accedidos directamente por el código en C (véase <a href="#3.3">&sect;3.3</a>). Son usadas como entornos por defecto por otras funciones C creadas por la función dada.

<p>Los entornos asociados con funciones en Lua son utilizados para resolver todos los accesos a las variables globales dentro de la función (véase <a href="#2.3">&sect;2.3</a>). Son usados también como entornos por defecto por otras funciones en Lua creadas por la función.

<p>Se puede cambiar el entorno de una función Lua o de un proceso en ejecución invocando <a href="#pdf-setfenv"><code>setfenv</code></a>. Se puede obtener el entorno de una función Lua o del proceso en ejecución invocando <a href="#pdf-getfenv"><code>getfenv</code></a>. Para manejar el entorno de otros objetos (<em>userdata</em>, funciones C, otros procesos) se debe usar la API de C.

<p><a name="2.10"></a><h2>2.10 - Liberación de memoria no utilizada</h2>

<p>Lua realiza automáticamente la gestión de la memoria. Esto significa que no debemos preocuparnos ni de asignar (o reservar) memoria para nuevos objetos ni de liberarla cuando los objetos dejan de ser necesarios. Lua gestiona la memoria automáticamente ejecutando un <em>liberador de memoria</em> (<em>garbage collector</em>) de cuando en cuando para eliminar todos los <em>objetos muertos</em> (esos objetos que ya no son accesibles desde Lua). Todos los objetos en Lua son susceptibles de gestión automática: tablas, <em>userdata</em>, funciones, procesos y <em>strings</em>.

<p>Lua implementa un liberador de memoria del tipo marcado-barrido incremental. Utiliza dos números para controlar sus ciclos de liberación de memoria: la <em>pausa del liberador de memoria</em> y el <em>multiplicador del paso del liberador de memoria</em>.

<p>La pausa del liberador de memoria controla cuánto tiempo debe esperar el liberador de memoria antes de comenzar un nuevo ciclo. Valores grandes hacen al liberador menos agresivo. Valores menores que 1 significan que el liberador no esperará para comenzar un nuevo ciclo. Un valor de 2 significa que el liberador espera que la memoria total en uso se doble antes de comenzar un nuevo ciclo.

<p>El multiplicador del paso controla la velocidad relativa del liberador en cuanto a asignación de memoria. Los valores más largos hacen el liberador más agresivo pero también aumentan el tamaño de cada paso incremental. Valores menores que 1 hacen el liberador demasiado lento y puede resultar en que el liberador nunca acabe un ciclo. El número por defecto, 2, significa que el liberador se ejecuta a una velocidad doble que la asignación de memoria.

<p>Se pueden cambiar esos números invocando en C a <a href="#lua_gc"><code>lua_gc</code></a> o en Lua a <a href="#pdf-collectgarbage"><code>collectgarbage</code></a>. Ambos tienen como argumentos un porcentaje (y entonces un argumento 100 significa un valor real de 1). Con esas funciones se puede también controlar el liberador directamente (por ejemplo, pararlo y reiniciarlo).

<p><a name="2.10.1"></a><h3>2.10.1 - Metamétodos de liberación de memoria</h3>

<p>Usando la API de C se pueden establecer metamétodos liberadores de memoria para <em>userdata</em> (véase <a href="#2.8">&sect;2.8</a>). Esos metamétodos se denominan también <em>finalizadores</em>. Éstos permiten coordinar el sistema de liberación de memoria de Lua con gestores externos de recursos (tales como cerrar ficheros, conexiones de red o de bases de datos, o liberar su propia memoria).

<p>Los <em>userdata</em> que se van a liberar con un campo <code>__gc</code> en sus metatablas no son liberados inmediatamente por el liberador de memoria. En su lugar Lua los pone en una lista. Después de eso Lua hace el equivalente a la siguiente función para cada <em>userdata</em> en la lista:
<pre> function gc_event (udata)
   local h = metatable(udata).__gc
   if h then
     h(udata)
   end
 end
</pre>

<p>Al final de cada ciclo de liberación de memoria, los finalizadores de <em>userdata</em> que aparecen en la lista que va a ser liberada son invocados en orden <em>inverso</em> al de su creación. Esto es, el primer finalizador en ser invocado es el que está asociado con el <em>userdata</em> creado en último lugar por el programa. El propio <em>userdata</em> puede ser liberado sólo en el próximo ciclo de liberación de memoria.

<p><a name="2.10.2"></a><h3>2.10.2 - Tablas débiles</h3>

<p>Una <em>tabla débil</em> es una tabla cuyos elementos son <em>referencias débiles</em>. Una referencia débil es ignorada por el liberador de memoria. En otras palabras, si las únicas referencias a un objeto son referencias débiles entonces se libera la memoria asociada con este objeto.

<p>Una tabla débil puede tener claves débiles, valores débiles o ambas cosas. Una tabla con claves débiles permite la liberación de sus claves, pero prohibe la liberación de sus valores. Una tabla con claves débiles y valores débiles permite la liberación tanto de claves como de valores. En cualquier caso, ya sea la clave o el valor el liberado, el par completo es eliminado de la tabla. La debilidad de una tabla está controlada por el campo <code>__mode</code> de su metatabla. Si el campo <code>__mode</code> es un <em>string</em> que contiene el carácter '<code>k</code>', las claves en la tabla son débiles. Si <code>__mode</code> contiene '<code>v</code>', los valores en la tabla son débiles.

<p>Después de usar una tabla como metatabla no se debería cambiar el valor de su campo <code>__mode</code>. En caso contrario el comportamiento débil de las tablas controladas por esa metatabla es indefinido.

<p><a name="2.11"></a><h2>2.11 - co-rutinas</h2>

<p>Lua tiene co-rutinas, también denominadas <em>multiprocesos colaborativos</em>. En Lua una co-rutina representa un proceso de ejecución independiente. A diferencia de los sistemas <em>multiproceso</em>, en Lua una co-rutina sólo suspende su ejecución invocando de manera explícita una función <em>yield</em> (cesión).

<p>Se pueden crear co-rutinas con una llamada a <code>coroutine.create</code>. El único argumento de esta función es otra función que es la función principal de la co-rutina.

<p>Cuando se llama por primera vez a <code>coroutine.resume</code>, pasándole como argumento el proceso retornado por <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>, la co-rutina comienza a ejecutarse en la primera línea de su función principal. Los argumentos extra pasados a <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> se pasan a su vez a la función principal de la co-rutina. Después de que la co-rutina empieza a ejecutarse lo hace hasta que termina o se produce una <em>cesión</em> del control de flujo del programa.

<p>Una co-rutina puede terminar su ejecución de dos maneras: normalmente, cuando su función principal retorna (explícita o implícitamente, después de su última instrucción); y anormalmente, si se produjo un error no protegido. En el primer caso, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> devuelve <b>true</b>, más cualquier valor retornado por la función principal de la co-rutina. En caso de error <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> devuelve <b>false</b> más un mensaje de error.

<p>Una co-rutina cede el control invocando a <code>coroutine.yield</code>. Cuando una co-rutina cede el control la correspondiente <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> retorna inmediatamente, incluso si la cesión ocurre dentro de una llamada a una función anidada (esto es, no en la función principal, sino en una función directa o indirectamente invocada desde la función principal). En el caso de una cesión, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> también devuelve <b>true</b>, más cualesquiera valores pasados a <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>. La próxima vez que se resuma la misma co-rutina, continuará su ejecución desde el punto en que fue realizada la cesión, con la llamada a <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> devolviendo cualquier argumento extra pasado a <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.

<p>La función <code>coroutine.wrap</code> crea una co-rutina, justo igual que lo haría <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>, pero en lugar de retornar la co-rutina misma, devuelve una función que, cuando es invocada resume la co-rutina. Cualesquiera argumentos pasados a esta función pasan como argumentos a <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>. <code>coroutine.wrap</code> devuelve todos los valores retornados por <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>, excepto el primero (el código booleano de error). A diferencia de <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>, <code>coroutine.wrap</code> no captura errores; cualquier error se propaga a la rutina invocante.

<p>Como ejemplo, considérese el siguiente código:
<pre>
   function foo (a)
     print("foo", a)
     return coroutine.yield(2*a)
   end
   
   co = coroutine.create(function (a,b)
         print("co-body", a, b)
         local r = foo(a+1)
         print("co-body", r)
         local r, s = coroutine.yield(a+b, a-b)
         print("co-body", r, s)
         return b, "end"
   end)
          
   print("main", coroutine.resume(co, 1, 10))
   print("main", coroutine.resume(co, "r"))
   print("main", coroutine.resume(co, "x", "y"))
   print("main", coroutine.resume(co, "x", "y"))
</pre>
Cuando se ejecuta se produce la siguiente salida:
<pre>
   co-body 1       10
   foo     2
   main    true    4
   co-body r
   main    true    11      -9
   co-body x       y
   main    true    10      end
   main    false   cannot resume dead coroutine
</pre>

<p>
<h1>3 - <a name="3">La interface del programa de aplicación (API)</a></h1>


<p>Esta sección describe la API de C para Lua, esto es, el conjunto de funciones C disponibles para que el programa anfitrión se comunique con Lua. Todas las funciones de la API y sus tipos y constantes relacionados están declaradas en el fichero de cabecera <code>lua.h</code>.

<p>Aunque se usa el término "function", algunas rutinas en la API pueden ser macros. Todas esas macros usan cada uno de sus argumentos exactamente una vez (excepto su primer argumento, que es siempre el estado de Lua), y por tanto no generan efectos laterales ocultos.

<p>Como en la mayoría de las bibliotecas de C, la funciones API de Lua no verifican la validez ni la consistencia de sus argumentos. Sin embargo se puede cambiar este comportamiento compilando Lua con las definiciones adecuadas para la macro <code>luai_apicheck</code>, en el fichero <code>luaconf.h</code>.

<p><a name="3.1"></a><h2>3.1 - La pila (<em>stack</em>)</h2>

<p>Lua usa una <em>pila virtual</em> para pasar valores a y desde C. Cada elemento en esta pila representa un valor de Lua (<b>nil</b>, número, <em>string</em>, etc.).

<p>Siempre que Lua llame al C, la función llamada obtiene una nueva pila, que es independiente de las pilas anteriores y de las pilas de las funciones C que todavía están activas. Esta pila contiene inicialmente cualquier argumento de la función C y es donde ésta coloca los resultados que deben ser devueltos a la rutina invocadora (véase <a href="#lua_CFunction"><code>lua_CFunction</code></a>).

<p>Por conveniencia, la mayoría de las operaciones de petición de la API no siguen una disciplina estricta de pila. En su lugar pueden referirse a cualquier elemento en la pila usando un <em>índice</em>: un valor positivo representa una posición <em>absoluta</em> en la pila (comenzando en 1); un valor negativo representa un <em>desplazamiento</em> relativo a la parte superior de la pila. Más específicamente, si la pila tiene <em>n</em> elementos, entonces el índice 1 representa el primer elemento (esto es, el elemento que fue colocado primero en la pila) y un índice <em>n</em> representa el último elemento; un índice <em>-1</em> también representa el último elemento (esto es, el elemento en la parte superior) y un índice <em>-n</em> representa el primer elemento. Decimos que un índice es <em>válido</em> si tiene un valor comprendido entre 1 y la parte superior de la pila (esto es, si <code>1 &le; abs(índice) &le; top</code>).
 

<p><a name="3.2"></a><h2>3.2 - El tamaño de la pila</h2>

<p>Cuando el programador interacciona con la API de Lua es responsable de asegurar la consistencia. En particular <em>es responsable de controlar el crecimiento correcto de la pila</em>. Se puede usar la función <a href="#lua_checkstack"><code>lua_checkstack</code></a> para hacer crecer el tamaño de la pila.

<p>Siempre que Lua llama al C, se asegura de que al menos existen <code>LUA_MINSTACK</code> posiciones disponibles en la pila. <code>LUA_MINSTACK</code> está definida como 20, así que normalmente el programador no tiene que preocuparse del espacio en la pila, a no ser que su código tenga bucles que coloquen elementos en la pila.

<p>La mayoría de las funciones de petición aceptan como índice cualquier valor dentro del espacio disponible en la pila, o sea índices hasta el máximo del tamaño de la pila establecido mediante <a href="#lua_checkstack"><code>lua_checkstack</code></a>. Esos índices se denominan <em>índices aceptables</em>.

Más formalmente, definimos un <em>índice aceptable</em> de la siguiente manera:
<pre>       (índice &lt; 0 &amp;&amp; abs(índice) &lt;= top) ||
       (índice &gt; 0 &amp;&amp; índice &lt;= stackspace)
</pre>
Nótese que 0 no es nunca un índice aceptable.

<p><a name="3.3"></a><h2>3.3 - Pseudoíndices</h2>

<p>Excepto en los casos en que se indique, cualquier función que acepta índices válidos también puede ser invocada con <em>pseudoíndices</em>, los cuales representan algunos valores en Lua que son accesibles desde el código en C pero que no están en la pila. Los pseudoíndices son usados para acceder al entorno del proceso, al entorno de la función, al registro y a los <em>upvalues</em> de una función C (véase <a href="#3.4">&sect;3.4</a>).

<p>El entorno del proceso (donde "viven" las variables globales) está siempre en el pseudoíndice <code>LUA_GLOBALSINDEX</code>. El entorno de una función C que está en ejecución está siempre en el pseudoíndice <code>LUA_ENVIRONINDEX</code>.

<p>Para acceder y cambiar el valor de una variable global se pueden usar operaciones normales de tabla en la tabla de entorno. Por ejemplo, para acceder al valor de una variable global se hace
<pre>       lua_getfield(L, LUA_GLOBALSINDEX, nombre_de_variable_global);
</pre>

<p><a name="3.4"></a><h2>3.4 - Instancias en C</h2>

<p>Cuando se crea una función C es posible asociarle algunos valores, creando una <em>instancia en C</em>; esos valores se denominan <em>upvalues</em> y son accesibles a la función en cualquier momento en que sea invocada (véase <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>).

<p>Siempre que se invoque a una función C sus <em>upvalues</em> se localizan en pseudoíndices específicos. Éstos se producen mediante la macro <code>lua_upvalueindex</code>. El primer valor asociado con una función está en la posición <code>lua_upvalueindex(1)</code>, y así sucesivamente. Cualquier acceso a <code>lua_upvalueindex(<em>n</em>)</code>, donde <em>n</em> es mayor que el número de <em>upvalues</em> de la función actual produce un índice aceptable pero inválido.

<p><a name="3.5"></a><h2>3.5 - El registro</h2>

<p>Lua proporciona un <em>registro</em>, una tabla predefinida que puede ser usada por cualquier código en C para almacenar cualquier valor que Lua necesite guardar. Esta tabla se localiza siempre en el pseudoíndice <code>LUA_REGISTRYINDEX</code>. Cualquier biblioteca de C puede almacenar datos en esta tabla, pero debería tener cuidado de elegir claves diferentes de aquéllas usadas por otras bibliotecas, para evitar conflictos. Típicamente se podría usar como clave un <em>string</em> conteniendo el nombre de la biblioteca o <em>userdata</em> "ligeros" con la dirección de un objeto de C en el código.

<p>Las claves de tipo entero en el registro son usadas como mecanismo para referenciar, implementado en la biblioteca auxiliar, y por tanto no deberían ser usados para otros propósitos diferentes.

<p><a name="3.6"></a><h2>3.6 - Manejo de errores en C</h2>

<p>Internamente Lua usa la función de C <code>longjmp</code> para facilitar el manejo de errores. (Se puede también elegir usar directamente excepciones si se trabaja en C++; véase el fichero <code>luaconf.h</code>.)  Cuando Lua se encuentra con cualquier error (tal como un error de asignación de memoria, un error de tipo, un error de sintaxis o un error de ejecución) entonces <em>activa</em> un error, esto es, realiza un salto largo en la memoria.  Un <em>entorno protegido</em> usa <code>setjmp</code> para establecer un punto de recuperación; cualquier error provoca un salto al punto de recuperación activo más reciente.

<p>Muchas funciones de la API pueden activar un error, por ejemplo debido a un problema de asignación de memoria. La documentación de cada función indica si puede activar un error.


<p>Dentro de una función C se puede activar un error invocando <a href="#lua_error"><code>lua_error</code></a>.

<p><a name="3.7"></a><h2>3.7 - Funciones y tipos</h2>

<p>He aquí la lista de todas las funciones y tipos de la API de C por orden alfabético. Cada función tiene un indicador como éste:
<span class="apii">[-o, +p, <em>x</em>]</span>

<p> El primer  campo, <code>o</code>, indica cuántos elementos elimina la función en la pila. El segundo campo, <code>p</code>, es cuantos elementos coloca la función en la pila. (Toda función siempre coloca sus resultados después de eliminar sus argumentos.) Un campo de la forma <code>x|y</code> significa que la función puede colocar (o eliminar) <code>x</code> ó <code>y</code> elementos, dependiendo de la situación; un signo de interrogación '<code>?</code>' significa que no se puede conocer cuántos elementos coloca/elimina la función observando sólo sus argumentos (por ejemplo, puede depender de lo qué esté en la pila). El tercer, campo <code>x</code>, indica si la función puede activar errores: '<code>-</code>' significa que la función nunca activa errores; '<code>m</code>' indica que la función puede activar un error sólo debido a falta de memoria; '<code>e</code>' indica que la función puede activar otros tipos de errores; '<code>v</code>' indica que la función puede activar un error a propósito.

<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>
typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>




<p>El tipo de la función que maneja la memoria usada por los estados de Lua. La función que maneja memoria debe proporcionar una funcionalidad similar a <code>realloc</code>, pero no exactamente la misma. Sus argumentos son: <code>ud</code>, un puntero opaco pasado a <a href="#lua_newstate"><code>lua_newstate</code></a>; <code>ptr</code>, un puntero al bloque que está siendo reservado/reasignado/liberado; <code>osize</code>, el tamaño original del bloque; <code>nsize</code>, el nuevo tamaño del bloque. <code>ptr</code> es <code>NULL</code> si y sólo si <code>osize</code> es cero. Cuando <code>nsize</code> es cero, el manejador debe retornar <code>NULL</code>; si <code>osize</code> no es cero debe ser liberado el bloque apuntado por <code>ptr</code>. Cuando <code>nsize</code> no es cero el manejador retorna <code>NULL</code> si y sólo si no puede ejecutar la petición. Cuando <code>nsize</code> no es cero y <code>osize</code> es cero el manejador debería comportarse como <code>malloc</code>. Cuando <code>nsize</code> y <code>osize</code> no son cero, el manejador se comporta como <code>realloc</code>. Lua asume que el manejador nunca falla cuando <code>osize &gt;= nsize</code>.

<p>He aquí una implementación simple para la función manejadora de memoria. Es usada en la biblioteca auxiliar por <a href="#lua_newstate"><code>lua_newstate</code></a>.
<pre>
   static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
     (void) ud;  (void) osize;  /* no usadas */
     if (nsize == 0) {
       free(ptr);
       return NULL;
     }
     else
       return realloc(ptr, nsize);
   }
</pre>

<p>
Este código asume que <code>free(NULL)</code> no tiene efecto y que <code>realloc(NULL, size)</code> es equivalente a <code>malloc(size)</code>. ANSI C asegura ambos comportamientos.

<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>




<p>Establece una nueva función de pánico y devuelve la vieja.

<p>Si ocurre un error fuera de cualquier entorno protegido Lua llama a la <em>función pánico</em> y luego invoca <code>exit(EXIT_FAILURE)</code>, saliendo por tanto de la aplicación anfitriona. Si usa otra función de pánico diferente, ésta puede evitar esta salida sin retorno (por ejemplo, haciendo un salto largo).

<p>La función de pánico puede acceder al mensaje de error en la parte superior de la pila.

<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>

<pre>
void lua_call (lua_State *L, int nargs, int nresults);</pre>




<p>Llama a una función.

<p>Para llamar a una función se debe usar el siguiente protocolo: primero, la función a ser invocada se coloca en la parte superior de la pila; entonces, se colocan también en la pila los argumentos de la función en orden directo; esto es, el primer argumento se coloca primero. Finalmente, se llama a <a href="#lua_call"><code>lua_call</code></a>; <code>nargs</code> es el número de argumentos que se han colocado en la pila. Todos los argumentos y el valor de la función se eliminan de la pila cuando la función es invocada. Los resultados de la función se colocan en la parte superior de la pila cuando retorna la función. El número de resultados se ajusta a <code>nresults</code>, a no ser que <code>nresults</code> sea <code>LUA_MULTRET</code>. En este caso se colocan <em>todos</em> los resultados de la función. Lua tiene cuidado de que los valores retornados se ajusten en el espacio de pila. Los resultados de la función son colocados en la pila en orden directo (el primero es colocado antes), por lo que después de la llamada el último resultado aparece en la parte superior de la pila.

<p>Cualquier error dentro de la función llamada se propaga hacia atrás (con un <code>longjmp</code>).

<p>El siguiente ejemplo muestra cómo puede el programa anfitrión hacer algo equivalente a este código en Lua:
<pre>    a = f("how", t.x, 14)
</pre>
Aquí está en C:
<pre>
    lua_getfield(L, LUA_GLOBALSINDEX, "f");          /* función que es llamada */
    lua_pushstring(L, "how");                              /* primer argumento */
    lua_getfield(L, LUA_GLOBALSINDEX, "t");           /* tabla que es indexada */
    lua_getfield(L, -1, "x");          /* coloca en la pila t.x (2º argumento) */
    lua_remove(L, -2);                               /* elimina 't' de la pila */
    lua_pushinteger(L, 14);                                    /* 3º argumento */
    lua_call(L, 3, 1);    /* llama a la función con 3 argumentos y 1 resultado */
    lua_setfield(L, LUA_GLOBALSINDEX, "a"); /* modifica la variable global 'a' */
</pre>
<p>
Téngase presente que el código de arriba está "equilibrado" al final, pues la pila ha vuelto a su configuración inicial. Esto está considerado como una buena práctica de programación.

<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>
typedef int (*lua_CFunction) (lua_State *L);</pre>




<p>Tipo para las funciones C.

<p>Con objeto de comunicar adecuadamente con Lua, una función C debe usar el siguiente protocolo, el cual define la manera en que son pasados los argumentos y los resultados: una función C recibe sus argumentos desde Lua en su pila en orden directo (el primer argumento se coloca primero). Por tanto, cuando comienza una función, <a href="#lua_gettop"><code>lua_gettop(L)</code></a> devuelve el número de argumentos recibidos por la función. Su primer argumento (si existe) está en el índice 1 y su último argumento está en el índice <a href="#lua_gettop"><code>lua_gettop(L)</code></a>. Para retornar valores a Lua una función C sólo los coloca en la pila, en orden directo (el primer resultado va primero), y retorna el número de resultados. Cualquier otro valor en la pila por debajo de los resultados debe ser adecuadamente descartado por Lua. Como una función Lua, una función C llamada desde Lua puede retornar varios resultados.

<p>Como ejemplo, la siguiente función recibe un número variable
de argumentos numéricos y retorna su media y su suma:
<pre>
     static int foo (lua_State *L) {
        int n = lua_gettop(L);   /* número de argumentos */
        lua_Number sum = 0;
        int i;
        for (i = 1; i &lt;= n; i++) {
          if (!lua_isnumber(L, i)) {
            lua_pushstring(L, "argumento incorrecto en la función 'media'");
            lua_error(L);
          }
          sum += lua_tonumber(L, i);
        }
        lua_pushnumber(L, sum/n);    /* primer resultado */
        lua_pushnumber(L, sum);     /* segundo resultado */
        return 2;                /* número de resultados */
     }
</pre>

<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>

<pre>
int lua_checkstack (lua_State *L, int extra);</pre>



<p>Se asegura de que hay al menos <code>extra</code> posiciones libres en la pila. Devuelve <code>false</code> si no puede hacer crecer la pila hasta ese tamaño. Esta función nunca disminuye la pila; si la pila es ya más grande que el nuevo tamaño la deja sin modificar.

<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
void lua_close (lua_State *L);</pre>



<p>Destruye todos los objetos en el estado dado de Lua (llamando al correspondiente metamétodo de liberación de memoria, si existe) y libera toda la memoria dinámica usada por este estado. En algunas plataformas puede no ser necesario llamar a esta función, debido a que todos los recursos se liberan de manera natural cuando finaliza el programa anfitrión. Por otro lado, programas de ejecución larga, como puede ser el <em>demonio</em> de un servidor web, pueden necesitar la liberación de estados tan pronto como éstos no se necesiten para evitar un crecimiento desmesurado.


<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>

<pre>
void lua_concat (lua_State *L, int n);</pre>



<p>Concatena los <code>n</code> valores de la parte superior de la pila, los elimina y deja el resultado en la parte superior de la pila. Si <code>n</code> es 1 el resultado es el valor simple en la pila (esto es, la función no hace nada); si <code>n</code> es 0 el resultado es un <em>string</em> vacío. La concatenación se realiza siguiendo la semántica normal de Lua (véase <a href="#2.5.4">&sect;2.5.4</a>).

<hr><h3><a name="lua_cpcall"><code>lua_cpcall</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>

<pre>
int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);</pre>




<p>Invoca la función C <code>func</code> en modo protegido. <code>func</code> comienza con un solo elemento en su pila, un <em>userdata</em> ligero conteniendo <code>ud</code>. En caso de errores <a href="#lua_cpcall"><code>lua_cpcall</code></a> devuelve el mismo código de error que <a href="#lua_pcall"><code>lua_pcall</code></a>, además del objeto error en la parte superior de la pila; en caso contrario retorna cero y no cambia la pila. Todos los valores retornados por <code>func</code> se descartan.

<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
void lua_createtable (lua_State *L, int narr, int nrec);</pre>



<p>Crea una nueva tabla vacía y la coloca en la pila. La nueva tabla tiene espacio reservado para <code>narr</code> elementos <em>array</em> y <code>nrec</code> elementos <em>no array</em>. Esta reserva es útil cuando no se sabe cuántos elementos va a contener la tabla. En otro caso se puede usar la función <a href="#lua_newtable"><code>lua_newtable</code></a>.

<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>

<pre>
int lua_dump (lua_State *L, lua_Writer writer, void *data);</pre>




<p>Vuelca una función en forma de <em>chunk</em> binario. Recibe una función de Lua en la parte superior de la pila y produce un <em>chunk</em> binario que si se carga de nuevo resulta en una función equivalente a la volcada previamente. Según va produciendo partes del <em>chunk</em>, <a href="#lua_dump"><code>lua_dump</code></a> invoca a la función <code>writer</code> (véase <a href="#lua_Writer"><code>lua_Writer</code></a>) con los datos <code>data</code> para escribirlos.

<p>El valor retornado es el código de error devuelto por la última llamada a <code>Writer</code>; 0 significa no error.

<p>Esta función no elimina de la pila la función de Lua.

<hr><h3><a name="lua_equal"><code>lua_equal</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>

<pre>
int lua_equal (lua_State *L, int index1, int index2);</pre>




<p>Retorna 1 si los dos valores en los índices aceptables <code>index1</code> e <code>index2</code> son iguales, siguiendo la semántica del operador <code>==</code> de Lua (esto es, puede invocar metamétodos). En otro caso retorna 0. También devuelve 0 si alguno de los índices no es válido.

<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>

<pre>
int lua_error (lua_State *L);</pre>




<p>Genera un error de Lua. El mensaje de error (que puede ser realmente un valor de Lua de cualquier tipo) debe de estar en la parte superior de la pila. Esta función realiza un salto largo, y por tanto nunca retorna. (véase <a href="#luaL_error"><code>luaL_error</code></a>).


<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>

<pre>
int lua_gc (lua_State *L, int what, int data);</pre>



<p>Controla el liberador de memoria.

<p>Esta función realiza varias tareas, de acuerdo con el valor del argumento <code>what</code>:
<ul>
<li> <code>LUA_GCSTOP</code> --- detiene el liberador de memoria.
</li><li> <code>LUA_GCRESTART</code> --- reinicia el liberador de memoria.
</li><li> <code>LUA_GCCOLLECT</code> --- realiza un ciclo completo de liberación de memoria.
</li><li> <code>LUA_GCCOUNT</code> --- retorna la cantidad actual de
memoria (en Kbytes) en uso por Lua.
</li><li> <code>LUA_GCCOUNTB</code> --- retorna el resto de dividir por 1024 la cantidad actual de memoria en bytes en uso por Lua.
</li><li> <code>LUA_GCSTEP</code> --- realiza un paso incremental de liberación de memoria. El "tamaño" del paso está controlado por <code>data</code> (un valor mayor significa más pasos) de una manera no especificada. Si se desea controlar el tamaño del paso se debe afinar experimentalmente el valor de <code>data</code>. La función retorna 1 si el paso acabó con un ciclo de liberación de memoria.
</li><li> <code>LUA_GCSETPAUSE</code> --- establece <code>data</code>/100 como el nuevo valor de la <em>pausa</em> del liberador de memoria (véase <a href="#2.10">&sect;2.10</a>). La función retorna el valor previo de la pausa. 
</li><li> <code>LUA_GCSETSTEPMUL</code> --- establece <code>data</code>/100 como el nuevo valor del <em>multiplicador del paso</em> del liberador de memoria (véase <a href="#2.10">&sect;2.10</a>). La función retorna el valor previo del multiplicador.
</li></ul>

<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>




<p>Retorna la función manejadora de memoria de un estado dado. Si <code>ud</code> no es <code>NULL</code> Lua guarda en <code>*ud</code> el puntero opaco pasado a <a href="#lua_newstate"><code>lua_newstate</code></a>.

<hr><h3><a name="lua_getfenv"><code>lua_getfenv</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
void lua_getfenv (lua_State *L, int index);</pre>

<p>Coloca en la pila la tabla de entorno de un valor en el índice dado.

<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>

<pre>
void lua_getfield (lua_State *L, int index, const char *k);</pre>




<p>Coloca en la pila el valor <code>t[k]</code>, donde <code>t</code> es el valor dado por el índice válido. Como en Lua esta función puede activar un metamétodo para el evento "index" (véase <a href="#2.8">&sect;2.8</a>).

<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>

<pre>
void lua_getglobal (lua_State *L, const char *name);</pre>




<p>Coloca en la pila el valor del <code>nombre</code> global. Está definida como macro:
<pre>
   #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)
</pre>

<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>

<pre>
int lua_getmetatable (lua_State *L, int index);</pre>




<p>Coloca en la pila la metatabla del valor situado en el índice aceptable dado. Si el índice no es válido o si el valor no tiene metatabla, la función retorna 0 y no coloca nada en la pila.

<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>

<pre>
void lua_gettable (lua_State *L, int index);</pre>




<p>Coloca en la pila el valor <code>t[k]</code>, donde <code>t</code> es el valor en el índice válido y <code>k</code> es el valor situado en la parte superior de la pila.

<p>Esta función quita la clave de la parte superior de la pila (colocando a su vez el valor resultante en su lugar). Como en Lua esta función puede activar un metamétodo para el evento "index" (véase <a href="#2.8">&sect;2.8</a>).

<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_gettop (lua_State *L);</pre>




<p>Retorna el índice del elemento situado en la parte superior de la pila. Debido a que los índices comienzan en 1 este resultado es igual al número de elementos en la pila (y así, 0 significa una pila vacía).

<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, <em>-</em>]</span>

<pre>
void lua_insert (lua_State *L, int index);</pre>




<p>Mueve el elemento situado en la parte superior de la pila hacia el índice válido dado, desplazando hacia arriba los elementos por encima de este índice para abrir hueco. No puede ser invocada con un pseudoíndice debido a que éste no es una posición real en la pila.


<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>
typedef ptrdiff_t lua_Integer;</pre>




<p>El tipo usado por la API de Lua para representar valores enteros.

<p>Por defecto es <code>ptrdiff_t</code>, que es normalmente el tipo entero con signo más grande que la máquina maneja "confortablemente".


<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_isboolean (lua_State *L, int index);</pre>



<p>Retorna 1 si el valor en la situación del índice aceptable tiene tipo booleano y 0 en caso contrario.

<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_iscfunction (lua_State *L, int index);</pre>




<p>Retorna 1 si el valor en la situación del índice aceptable es una función C y 0 en caso contrario.

<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_isfunction (lua_State *L, int index);</pre>



<p>Retorna 1 si el valor en la situación del índice aceptable es una función (en C o en Lua) y 0 en caso contrario.

<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_islightuserdata (lua_State *L, int index);</pre>



<p>Retorna 1 si el valor en la situación del índice aceptable es un <em>userdata</em> ligero y 0 en caso contrario.

<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_isnil (lua_State *L, int index);</pre>


<p>Retorna 1 si el valor en la situación del índice aceptable es <b>nil</b> y 0 en caso contrario.


<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_isnone (lua_State *L, int index);</pre>




<p>Retorna 1 si el valor en la situación del índice aceptable es no válido (esto es, si se refiere a un elemento fuera de la pila actual) y 0 en caso contrario.

<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_isnoneornil (lua_State *L, int index);</pre>



<p>Retorna 1 si el valor en la situación del índice aceptable es no válido (esto es, si se refiere a un elemento fuera de la pila actual) o si el valor en este índice es <code>nil</code>, y 0 en caso contrario.

<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_isnumber (lua_State *L, int index);</pre>




<p>Retorna 1 si el valor en la situación del índice aceptable es un número o un <em>string</em> convertible a número y 0 en caso contrario.

<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_isstring (lua_State *L, int index);</pre>


<p>Retorna 1 si el valor en la situación del índice aceptable es un <em>string</em> o un número (que es siempre convertible a un <em>string</em>) y 0 en caso contrario.

<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_istable (lua_State *L, int index);</pre>


<p>Retorna 1 si el valor en la situación del índice aceptable es una tabla y 0 en caso contrario.

<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_isthread (lua_State *L, int index);</pre>


<p>Retorna 1 si el valor en la situación del índice aceptable es un proceso y 0 en caso contrario.

<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_isuserdata (lua_State *L, int index);</pre>



<p>Retorna 1 si el valor en la situación del índice aceptable es un <em>userdata</em> (ligero o completo) y 0 en caso contrario.

<hr><h3><a name="lua_lessthan"><code>lua_lessthan</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>

<pre>
int lua_lessthan (lua_State *L, int index1, int index2);</pre>




<p>Retorna 1 si el valor situado en la posición del índice aceptable <code>index1</code> es menor que el situado en la posición del índice aceptable <code>index2</code>, siguiendo la semántica del operador <code>&lt;</code> de Lua (esto es, puede invocar metamétodos). En caso contrario retorna 0. También retorna 0 si alguno de los índices es inválido.

<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);</pre>



<p>Carga un <em>chunk</em> de Lua. Si no hay errores, <a href="#lua_load"><code>lua_load</code></a> coloca el <em>chunk</em> compilado en la parte superior de la pila. En caso contrario coloca ahí un mensaje de error. Los valores de retorno de <a href="#lua_load"><code>lua_load</code></a> son:
<ul>
<li> 0 --- sin errores.
</li><li> <code>LUA_ERRSYNTAX</code> ---
error de sintaxis durante la precompilación.
</li><li> <code>LUA_ERRMEM</code> ---
error de reserva de memoria.
</li></ul>

<p><a href="#lua_load"><code>lua_load</code></a> detecta automáticametne si el <em>chunk</em> está en binario o en forma de texto, y lo carga de acuerdo con esto (véase el programa <code>luac</code>).

<p><a href="#lua_load"><code>lua_load</code></a> usa una función <code>lectora</code> suplida por el usuario para leer el <em>chunk</em> (véase <a href="#lua_Reader"><code>lua_Reader</code></a>). El argumento <code>data</code> es un valor opaco pasado a la función lectora. <p>El argumento <code>chunkname</code> da un nombre al <em>chunk</em>. el cual es usado en los mensajes de error y en la información de depuración (véase <a href="#3.8">&sect;3.8</a>).

<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>



<p>Crea un nuevo estado independiente. Retorna <code>NULL</code> si no puede crear el estado (debido a falta de memoria). El argumento <code>f</code> es la función de reserva de memoria; Lua hace toda la reserva de memoria para este estado a través de esta función. El segundo argumento, <code>ud</code>, es un puntero opaco que Lua simplemente pasa al reservador de memoria en cada llamada.

<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
void lua_newtable (lua_State *L);</pre>




<p>Crea una nueva tabla vacía y la coloca en la pila. Equivale a <code>lua_createtable(L, 0, 0)</code>.

<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
lua_State *lua_newthread (lua_State *L);</pre>



<p>Crea un nuevo proceso, lo coloca en la pila y retorna un puntero a un <a href="#lua_State"><code>lua_State</code></a> que representa este nuevo proceso. El nuevo estado retornado por esta función comparte con el original todos los objetos globales (como las tablas), pero tiene una pila de ejecución independiente.

<p>No existe una función explícita para cerrar o destruir un proceso. Los procesos están sujetos a liberación de memoria, como cualquier otro objeto de Lua.

<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
void *lua_newuserdata (lua_State *L, size_t size);</pre>



<p>Esta función reserva un nuevo bloque de memoria con el tamaño dado, coloca en la pila un nuevo <em>userdata</em> completo con la dirección del bloque de memoria y retorna esta dirección.

<p>Los <em>userdata</em> representan valores de C en Lua. Un <em>userdata completo</em> representa un bloque de memoria. Es un objeto (como una tabla): se puede crear, puede tener su propia metatabla y se puede detectar cuándo está siendo eliminado de memoria. Un <em>userdata</em> completo es sólo igual a sí mismo (en un test de igualdad directa).

<p>Cuando Lua libera un <em>userdata</em> completo con un metamétodo <code>gc</code>, llama al metamétodo y marca el <em>userdata</em> como finalizado. Cuando este <em>userdata</em> es liberado de nuevo entonces es cuando Lua libera definitivamente la memoria correspondiente.

<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>

<pre>
int lua_next (lua_State *L, int index);</pre>


<p>Elimina una clave de la pila y coloca un par clave-valor de una tabla en el índice dado (la "siguiente" pareja después de la clave dada). Si no hay más elementos en la tabla entonces <a href="#lua_next"><code>lua_next</code></a> retorna 0 (y no coloca nada en la pila).

<p>Una típica iteración de recorrido de tabla sería:
<pre>       /* la tabla está en la pila en el índice 't' */
       lua_pushnil(L);  /* primera clave */
       while (lua_next(L, t) != 0) {
         /* 'clave' está en el índice -2 y 'valor' en el índice -1 */
         printf("%s - %s\n",
                lua_typename(L, lua_type(L, -2)), 
                lua_typename(L, lua_type(L, -1)));
         /* elimina 'valor'; mantiene 'clave' para la siguiente iteración */
         lua_pop(L, 1);
       }
</pre>

<p>Mientras se recorre una tabla no debe llamarse a <a href="#lua_tolstring"><code>lua_tolstring</code></a> directamente en una clave a no ser que se conozca que la clave es realmente un <em>string</em>. Recuerde que <a href="#lua_tolstring"><code>lua_tolstring</code></a> <em>cambia</em> el valor en el índice dado; esto confunde a la siguiente llamada a <a href="#lua_next"><code>lua_next</code></a>.

<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>
typedef double lua_Number;</pre>



<p>El tipo de los números en Lua. Por defecto es un <code>double</code>, pero puede ser cambiado en <code>luaconf.h</code>.

<p>A través del fichero de configuración se puede cambiar Lua para que opere con otro tipo de números (por ejemplo, <code>float</code> o <code>long</code>).

<hr><h3><a name="lua_objlen"><code>lua_objlen</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
size_t lua_objlen (lua_State *L, int index);</pre>



<p>Retorna la "longitud" de un valor situado en el índice aceptable: para un <em>string</em>, es la longitud del mismo; para una tabla, es el resultado del operador longitud ('<code>#</code>'); para un <em>userdata</em>, es el tamaño del bloque de memoria reservado para el mismo; para otros valores es 0.

<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), <em>-</em>]</span>

<pre>
int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);</pre>



<p>Invoca una función en modo protegido.

<p>Tanto <code>nargs</code> como <code>nresults</code> tienen el mismo significado que en <a href="#lua_call"><code>lua_call</code></a>. Si no hay errores durante la llamada, <a href="#lua_pcall"><code>lua_pcall</code></a> se comporta exactamente igual que <a href="#lua_call"><code>lua_call</code></a>. Sin embargo en caso de error <a href="#lua_pcall"><code>lua_pcall</code></a> lo captura, colocando un único valor en la pila (el mensaje de error) y retorna un código de error. Como <a href="#lua_call"><code>lua_call</code></a>, <a href="#lua_pcall"><code>lua_pcall</code></a> siempre elimina la función y sus argumentos de la pila.

<p>Si <code>errfunc</code> es 0 entonces el mensaje de error retornado en la pila es exactamente el mensaje original. En otro caso, <code>errfunc</code> es el índice en la pila de una <em>función manejadora de error</em>. (En la implementación actual, este índice no puede ser un pseudoíndice.) En caso de errores de ejecución esta función será llamada con el mensaje de error y el valor devuelto será el mensaje retornado en la pila por <a href="#lua_pcall"><code>lua_pcall</code></a>.

<p>Típicamente la función manejadora de error se usa para añadir más información de depuración al mensaje de error, tal como un "trazado inverso" de la pila. Esa información no puede ser recolectada después del retorno de <a href="#lua_pcall"><code>lua_pcall</code></a>, puesto que por entonces la pila ya no tiene esa información.

<p>La función <a href="#lua_pcall"><code>lua_pcall</code></a> retorna 0 en caso de éxito o uno de los siguientes códigos de error (definidos en <code>lua.h</code>):
<ul>
<li> <code>LUA_ERRRUN</code> --- un error de ejecución.
</li><li> <code>LUA_ERRMEM</code> --- un error de reserva de memoria. Para este error Lua no llama a la función manejadora de error.
</li><li> <code>LUA_ERRERR</code> ---
error mientras se está ejecutando la función manejadora de error.
</li></ul>

<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, <em>-</em>]</span>

<pre>
void lua_pop (lua_State *L, int n);</pre>



<p>Elimina <code>n</code> elementos de la pila.

<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
void lua_pushboolean (lua_State *L, int b);</pre>


<p>Coloca el valor booleano <code>b</code> en la pila.

<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p><span class="apii">[-n, +1, <em>m</em>]</span>

<pre>
void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>


<p>Coloca en la pila una nueva instancia en C.

<p>Cuando se crea una función C es posible asociarle algunos valores, creando entonces una <em>instancia en C</em> (véase <a href="#3.4">&sect;3.4</a>); estos valores son entonces accesibles a la función en cualquier momento en que sea invocada. Para asociar valores a una función C, primero éstos deberían colocarse en la pila (cuando hay varios, el primero se coloca antes).  Entonces se invoca <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> para crear y colocar la función C en la pila, con el argumento <code>n</code> indicando cuantos valores están asociados con la misma. <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> también elimina esos valores de la pila.

<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>



<p>Coloca una función C en la pila. Esta función recibe un puntero a una función C y coloca en la pila un valor de Lua de tipo <code>function</code> que, cuando se llama, invoca la correspondiente función C.

<p>Cualquier función que sea registrada en Lua debe seguir el protocolo correcto para recibir sus argumentos y devolver sus resultados (véase <a href="#lua_CFunction"><code>lua_CFunction</code></a>).

<p><code>lua_pushcfunction(L, f)</code> está definida como una macro:

<pre>
   #define lua_pushcfunction(L, f)  lua_pushcclosure(L, f, 0)
</pre>

<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>Coloca en la pila un <em>string</em> formateado y retorna un puntero a este <em>string</em>. Es similar a la función <code>sprintf</code> de C, pero tiene con ella algunas importantes diferencias:
<ul>
<li> No tiene que reservar memoria para el resultado, puesto que éste es un <em>string</em> de Lua, y Lua se encarga de realizar la reserva de memoria (y también la liberación).
</li><li> Los especificadores de conversión son bastante restrictivos. No hay indicadores, anchuras o precisiones. Los especificadores de conversión pueden ser sólo: '<code>%%</code>' (inserta un '<code>%</code>' en el <em>string</em>), '<code>%s</code>' (inserta un <em>string</em> terminado en cero sin restricciones de tamaño), '<code>%f</code>' (inserta un <a href="#lua_Number"><code>lua_Number</code></a>), '<code>%p</code>' (inserta un puntero como número hexadecimal), '<code>%d</code>' (inserta un <code>int</code>), y '<code>%c</code>' (inserta un <code>int</code> como carácter).
</li></ul>

<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
void lua_pushinteger (lua_State *L, lua_Integer n);</pre>


<p>Coloca un número entero de valor <code>n</code> en la pila.

<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
void lua_pushlightuserdata (lua_State *L, void *p);</pre>



<p>Coloca un <em>userdata</em> ligero en la pila.

<p>Los <em>userdata</em> representan valores de C en Lua. Un <em>userdata ligero</em> representa un puntero. Es un valor (como un número): no se crea ni tiene metatablas y no sufre liberación de memoria (puesto que nunca fue reservada).  En una comparación de igualdad, un <em>userdata ligero</em> es igual que cualquier otro <em>userdata ligero</em> con la misma dirección en C.


<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
Esta macro es equivalente a <a href="#lua_pushlstring"><code>lua_pushlstring</code></a>,
pero puede ser usada solamente cuando <code>s</code> es un <em>string</em> literal.
En esos casos, proporciona automáticamente la longitud del <em>string</em>.

<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
void lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>


<p>Coloca el <em>string</em> apuntado por <code>s</code> con tamaño <code>len</code> en la pila. Lua realiza (o reutiliza) una copia interna del <em>string</em> dado, así que la memoria en <code>s</code> puede ser liberada o reutilizada inmediamente después de que la función retorne. El <em>string</em> puede contener ceros.

<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
void lua_pushnil (lua_State *L);</pre>


<p>Coloca un valor nil en la pila.

<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
void lua_pushnumber (lua_State *L, lua_Number n);</pre>


<p>Coloca un número con valor <code>n</code> en la pila.

<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
void lua_pushstring (lua_State *L, const char *s);</pre>


<p>Coloca el <em>string</em> terminado en cero al que apunta <code>s</code> en la pila. Lua realiza (o reutiliza) una copia interna del <em>string</em> dado, así que la memoria en <code>s</code> puede ser liberada o reutilizada inmediamente después de que la función retorne. El <em>string</em> no puede contener caracteres cero; se asume que el final del mismo es el primer carácter cero que aparezca.

<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
int lua_pushthread (lua_State *L);</pre>


<p>Coloca un proceso representado por <code>L</code> en la pila. Retorna 1 si este proceso es el proceso principal de su estado.

<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
void lua_pushvalue (lua_State *L, int index);</pre>


<p>Coloca una copia del elemento situado en el índice válido dado en la pila.

<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p><span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>


<p>Equivalente a <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>, excepto que recibe un argumento de tipo <code>va_list</code> en lugar de un número variable de argumentos.

<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_rawequal (lua_State *L, int index1, int index2);</pre>


<p>Retorna 1 si los dos valores situados en los índices aceptables <code>index1</code> e <code>index2</code> son iguales de manera primitiva (esto es, sin invocar metamétodos). En caso contrario retorna 0. También retorna 0 si alguno de los índices no es válido.

<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, <em>-</em>]</span>

<pre>
void lua_rawget (lua_State *L, int index);</pre>


<p>Similar a <a href="#lua_gettable"><code>lua_gettable</code></a>, pero realiza un acceso directo (sin metamétodos).

<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
void lua_rawgeti (lua_State *L, int index, int n);</pre>


<p>Coloca en la pila el valor <code>t[n]</code>, donde <code>t</code> es el valor en el índice válido. El acceso es directo, esto es, sin invocar metamétodos.

<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>

<pre>
void lua_rawset (lua_State *L, int index);</pre>


<p>Similar a <a href="#lua_settable"><code>lua_settable</code></a>, pero realizando una asignación directa (sin invocar metamétodos).

<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>

<pre>
void lua_rawseti (lua_State *L, int index, int n);</pre>


<p>Realiza el equivalente a <code>t[n] = v</code>, donde <code>t</code> es el valor en el índice válido y <code>v</code> es el valor en la parte superior de la pila.

<p>Esta función elimina el valor de la parte superior de la pila. La asignación es directa, sin invocar metamétodos.

<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>
typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>


<p>La función de lectura usada por <a href="#lua_load"><code>lua_load</code></a>. Cada vez que necesita otro fragmento de <em>chunk</em>, <a href="#lua_load"><code>lua_load</code></a> llama al "lector", pasándole su argumento <code>data</code>. El lector debe retornar un puntero a un bloque de memoria con un nuevo fragmento de <em>chunk</em> y establece <code>size</code> como el tamaño del bloque. El bloque debe existir hasta que la función lectora se invoque de nuevo. Para señalar el final del <em>chunk</em> el lector debe retornar <code>NULL</code>. La función lectora puede retornar fragmentos de cualquier tamaño mayor que cero.

<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>

<pre>
void lua_register (lua_State *L,
                   const char *name,
                   lua_CFunction f);</pre>


<p>Establece la función C <code>f</code> como el nuevo valor del <code>nombre</code> global. Está definida en la macro:

<pre>
   #define lua_register(L,n,f) \
          (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>

<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>

<pre>
void lua_remove (lua_State *L, int index);</pre>


<p>Elimina el elemento en la posición del índice válido dado, desplazando hacia abajo los elementos que estaban por encima de este índice para llenar el hueco. No puede ser llamada con un pseudoíndice, debido a que éste no es una posición real en la pila.

<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>

<pre>
void lua_replace (lua_State *L, int index);</pre>


<p>Mueve el elemento que está en la parte superior de la pila a la posición dada (y lo elimina de la parte superior de la pila), sin desplazar ningún elemento de la misma (por tanto reemplazando el valor en la posición dada).

<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>

<pre>
int lua_resume (lua_State *L, int narg);</pre>


<p>Comienza y resume una co-rutina en un proceso dado.

<p>Para comenzar una co-rutina se debe crear un nuevo proceso (véase <a href="#lua_newthread"><code>lua_newthread</code></a>); entonces se coloca en su propia pila la función principal más cualquier posible argumento; posteriormente se invoca <a href="#lua_resume"><code>lua_resume</code></a>, con <code>narg</code> siendo el número de argumentos. Esta llamada retorna cuando la co-rutina suspende o finaliza su ejecución. Cuando retorna, la pila contiene todos los valores pasados a <a href="#lua_yield"><code>lua_yield</code></a>, o todos los valores retornados por el cuerpo de la función. <a href="#lua_resume"><code>lua_resume</code></a> retorna <a href="#lua_yield"><code>LUA_YIELD</code></a> si la co-rutina cedió el control, 0 si la co-rutina acabó su ejecución sin errores, o un código de error en caso de errores (véase <a href="#lua_pcall"><code>lua_pcall</code></a>). En caso de error, se deja información en la pila, así que se puede usar la API de depuración con ella. El mensaje de error está en la parte superior de la pila. Para reiniciar una co-rutina se ponen en la pila sólo los valores que son pasados como resultado de <code>yield</code>, y entonces se invoca <a href="#lua_resume"><code>lua_resume</code></a>.

<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>


<p>Utiliza <code>f</code> con el <em>userdata</em> <code>ud</code> como función de reserva de memoria de un estado dado .

<hr><h3><a name="lua_setfenv"><code>lua_setfenv</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>

<pre>
int lua_setfenv (lua_State *L, int index);</pre>




<p>Elimina una tabla de la parte superior de la pila y la toma como nuevo entorno para el valor situado en la posición del índice. Si el valor dado no es ni una función ni un proceso ni un <em>userdata</em> entonces <a href="#lua_setfenv"><code>lua_setfenv</code></a> retorna 0. En caso contrario retorna 1.

<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>

<pre>
void lua_setfield (lua_State *L, int index, const char *k);</pre>


<p>Realiza el equivalente a <code>t[k] = v</code>, donde <code>t</code> es el valor en la posición del índice válido y <code>v</code> es el valor en la parte superior de la pila.

<p>Esta función elimina el valor de la pila. Como en Lua, esta función puede activar un metamétodo para el evento "newindex" (véase <a href="#2.8">&sect;2.8</a>).

<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>

<pre>
void lua_setglobal (lua_State *L, const char *name);</pre>


<p>Elimina un valor de la pila y lo toma como nuevo valor del
<code>nombre</code> global. Está definida en una macro:
<pre>
   #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)
</pre>

<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>

<pre>
int lua_setmetatable (lua_State *L, int index);</pre>


<p>Elimina una tabla de la pila y la toma como nueva metatabla para el valor en la situación del índice aceptable.

<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>

<pre>
void lua_settable (lua_State *L, int index);</pre>


<p>Hace el equivalente a <code>t[k] = v</code>, donde <code>t</code> es el valor en la posición del índice válido, <code>v</code> es el valor en la parte superior de la pila y <code>k</code> es el valor justamente debajo.

<p>Esta función elimina de la pila tanto la clave como el valor. Como en Lua, esta función puede activar un metamétodo para el evento "newindex" (véase <a href="#2.8">&sect;2.8</a>).

<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>

<pre>
void lua_settop (lua_State *L, int index);</pre>


<p>Acepta cualquier índice aceptable ó 0 y establece la parte superior de la pila en este índice. Si ese valor es mayor que el antiguo entonces los nuevos elementos se rellenan con <b>nil</b>. Si <code>index</code> es 0 entonces todos los elementos de la pila se eliminan.

<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>
typedef struct lua_State lua_State;</pre>



<p>Estructura opaca que almacena todo el estado de un intérprete de Lua. La biblioteca de Lua es totalmente re-entrante: no tiene variables globales. Toda la información acerca de un estado se guarda en esta estructura.

<p>Un puntero a este estado debe ser pasado como primer argumento a cualquier función de la biblioteca, excepto a <a href="#lua_newstate"><code>lua_newstate</code></a>, la cual crea un nuevo estado de Lua desde cero.

<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_status (lua_State *L);</pre>




<p>Retorna el estatus del proceso <code>L</code>.

<p>El estatus puede ser 0 para un proceso normal, un código de error si el proceso finaliza su ejecución con un error, o <code>LUA_YIELD</code> si el proceso está suspendido.

<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_toboolean (lua_State *L, int index);</pre>



<p>Convierte el valor de Lua situado en la posición del índice aceptable en un booleano de C (0 ó 1). Como todos los test en Lua, <a href="#lua_toboolean"><code>lua_toboolean</code></a> retorna 1 para cada valor de Lua diferente de <b>false</b> y <b>nil</b>; en caso contrario retorna 0. También retorna 0 cuando se invoca sin un índice válido. (Si se desea aceptar sólo los valores booleanos reales, úsese <a href="#lua_isboolean"><code>lua_isboolean</code></a> para verificar el tipo del valor.)

<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>


<p>Convierte en una función C el valor situado en el índice aceptable. Este valor debe ser una función C; en caso contrario retorna <code>NULL</code>.

<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
lua_Integer lua_tointeger (lua_State *L, int index);</pre>



<p>Convierte el valor de Lua situado en el índice aceptable en un entero sin signo del tipo <a href="#lua_Integer"><code>lua_Integer</code></a>. El valor de Lua debe ser un número o un <em>string</em> convertible a un número (véase <a href="#2.2.1">&sect;2.2.1</a>); en otro caso <a href="#lua_tointeger"><code>lua_tointeger</code></a> retorna 0.

<p>Si el número no es entero se trunca de una manera no especificada.

<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>

<pre>
const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>


<p>Convierte el valor de Lua situado en la posición del índice aceptable en un <em>string</em> (<code>const char*</code>). Si <code>len</code> no es <code>NULL</code>, también establece <code>*len</code> como longitud del mismo. El valor Lua puede ser un <em>string</em> o un número; en caso contrario la función retorna <code>NULL</code>. Si el valor es un número entonces <a href="#lua_tolstring"><code>lua_tolstring</code></a> también <em>cambia el valor actual en la pila a un string</em>. (Este cambio confunde a <a href="#lua_next"><code>lua_next</code></a> cuando <a href="#lua_tolstring"><code>lua_tolstring</code></a> se aplica a claves durante el recorrido de una tabla.)

<p><a href="#lua_tolstring"><code>lua_tolstring</code></a> retorna un puntero totalmente alineado a un <em>string</em> dentro de un estado de Lua. Este <em>string</em> siempre tiene un cero ('<code>\0</code>') después de su último carácter (como en C), pero puede contener otros ceros en su cuerpo. Debido a que Lua tiene liberación de memoria, no existen garantías de que el puntero retornado por <a href="#lua_tolstring"><code>lua_tolstring</code></a> siga siendo válido después de que el valor correspondiente sea eliminado de la pila.

<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
lua_Number lua_tonumber (lua_State *L, int index);</pre>



<p>Convierte el valor Lua dado en la posicion del índice aceptable en un número (véase <a href="#lua_Number"><code>lua_Number</code></a>). El valor Lua debe ser un número o un <em>string</em> convertible a número (véase <a href="#2.2.1">&sect;2.2.1</a>); en caso contrario <a href="#lua_tonumber"><code>lua_tonumber</code></a> retorna 0.

<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
const void *lua_topointer (lua_State *L, int index);</pre>


<p>Convierte el valor situado en el índice aceptable en un puntero genérico de C (<code>void*</code>). El valor puede ser un <em>userdata</em>, una tabla, un proceso o una función; en caso contrario <a href="#lua_topointer"><code>lua_topointer</code></a> retorna <code>NULL</code>. Lua se asegura de que diferentes objetos retornen diferentes punteros. No hay una manera directa de convertir un puntero de nuevo a su valor original.

<p>Típicamente esta función sólo es usada para información de depuración.

<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>

<pre>
const char *lua_tostring (lua_State *L, int index);</pre>


<p>Equivalente a <a href="#lua_tolstring"><code>lua_tolstring</code></a> 
con <code>len</code> igual a <code>NULL</code>.

<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
lua_State *lua_tothread (lua_State *L, int index);</pre>


<p>Convierte el valor en la posición del índice aceptable en un proceso de Lua (representado como <code>lua_State*</code>). Este valor debe ser un proceso; en caso contrario la función retorna <code>NULL</code>.

<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
void *lua_touserdata (lua_State *L, int index);</pre>


<p>Si el valor en la posición del índice aceptable es un <em>userdata</em> completo retorna la dirección de su bloque de memoria. Si el valor es un <em>userdata</em> ligero retorna su puntero. En otro caso retorna <code>NULL</code>.

<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_type (lua_State *L, int index);</pre>



<p>Retorna el tipo del valor situado en el índice aceptable o <code>LUA_TNONE</code> si la dirección es inválida (esto es, un índice a una posición "vacía" en la pila). Los tipos retornados por <a href="#lua_type"><code>lua_type</code></a> están codificados por las siguientes constantes, definidas en <code>lua.h</code>:
<code>LUA_TNIL</code>,
<code>LUA_TNUMBER</code>,
<code>LUA_TBOOLEAN</code>,
<code>LUA_TSTRING</code>,
<code>LUA_TTABLE</code>,
<code>LUA_TFUNCTION</code>,
<code>LUA_TUSERDATA</code>,
<code>LUA_TTHREAD</code>
y <code>LUA_TLIGHTUSERDATA</code>.

<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
const char *lua_typename  (lua_State *L, int tp);</pre>


<p>Retorna el nombre del tipo codificado por el valor <code>tp</code>, el cual debe ser uno de los valores retornados <a href="#lua_type"><code>lua_type</code></a>.

<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>
typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>



<p>La función escritora usada por <a href="#lua_dump"><code>lua_dump</code></a>. Cada vez que produce otro fragmento de <em>chunk</em>, <a href="#lua_dump"><code>lua_dump</code></a> llama al escritor, pasándole el <a href="#buffer"><em>buffer</em></a> para ser escrito (<code>p</code>), su tamaño (<code>sz</code>) y el argumento <code>data</code> proporcionado a <a href="#lua_dump"><code>lua_dump</code></a>.

<p>El escritor retorna un código de error: 0 significa no errores y cualquier otro valor significa un error y evita que <a href="#lua_dump"><code>lua_dump</code></a> llame de nuevo al escritor.

<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>

<pre>
void lua_xmove (lua_State *from, lua_State *to, int n);</pre>



<p>Intercambia valores entre diferentes procesos del <em>mismo</em> estado global.

<p>Esta función elimina <code>n</code> valores de la pila indicada por <code>from</code> y los coloca en la pila indicada por <code>to</code>.

<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>

<pre>
int lua_yield  (lua_State *L, int nresults);</pre>


<p>Produce la cesión de una co-rutina.

<p>Esta función debería ser llamada solamente como expresión de retorno de una función C, como sigue:
<pre>
   return lua_yield (L, nresults);
</pre>
Cuando una función C llama a <a href="#lua_yield"><code>lua_yield</code></a> de esta manera, la co-rutina que está ejecutándose suspende su ejecución, y la llamada a <a href="#lua_resume"><code>lua_resume</code></a> que comenzó esta co-rutina retorna. El argumento <code>nresults</code> es el número de valores de la pila que son pasados como resultados a <a href="#lua_resume"><code>lua_resume</code></a>.

<p>
<a name="3.8"></a><h2>3.8 - El interface de depuración</h2>

<p>Lua no tiene utilidades de depuración internas. En su lugar ofrece una interface especial por medio de funciones y <a href="#hook"><em>hooks</em></a>. Esta interface permite la construcción de diferentes tipos de depuradores, analizadores de código y otras herramientas que necesitan "información interna" del intérprete.

<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>
typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int nups;                   /* (u) number of upvalues */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>



<p>Una estructura usada para contener diferentes fragmentos de información acerca de la función activa.  <a href="#lua_getstack"><code>lua_getstack</code></a> rellena sólo la parte privada de esta estructura, para su uso posterior.  Para rellenar otros campos de <a href="#lua_debug"><code>lua_debug</code></a> con información útil, llámese a <a href="#lua_getinfo"><code>lua_getinfo</code></a>.

<p>Los campos de <a href="#lua_debug"><code>lua_debug</code></a> tienen el siguiente significado:
<ul>
<li><b><code>source</code>:</b>
Si la función fue definida en un <em>string</em> entonces <code>source</code> es ese <em>string</em>. Si la función fue definida en un fichero entonces <code>source</code> comienza con un carácter '<code>@</code>' seguido del nombre del fichero.

</li><li><b><code>short_src</code>:</b>
una versión "imprimible" de <code>source</code>, que será usada en los mensajes de error.

</li><li><b><code>linedefined</code>:</b>
el número de línea donde comienza la definición de la función.

</li><li><b><code>lastlinedefined</code>:</b>
el número de línea donde acaba la definición de función.

</li><li><b><code>what</code>:</b>
el <em>string</em> <code>"Lua"</code> si la función es una función Lua, <code>"C"</code> si la función es una función C, <code>"main"</code> si es la parte principal de un <em>chunk</em>, y <code>"tail"</code> si es una función que realiza una llamada de cola. Es el último caso Lua no tiene más información acerca de la función.

</li><li><b><code>currentline</code>:</b>
la línea actual donde la función dada se está ejecutando. Cuando esta información no está disponible, <code>currentline</code> toma el valor <em>-1</em>.

</li><li><b><code>name</code>:</b>
un nombre razonable para la función dada. Debido a que las funciones en Lua son valores de primera clase, no tienen un nombre fijo: algunas funciones pueden ser el valor de variables globales, mientras que otras pueden ser almacenadas sólo en un campo de una tabla. La función <code>lua_getinfo</code> analiza cómo fue invocada la función para encontrarle un nombre adecuado. Si no puede encontrarlo entonces <code>nombre</code> se hace <code>NULL</code>.

</li><li><b><code>namewhat</code>:</b>
explica el campo <code>nombre</code>. El valor de <code>namewhat</code> puede ser <code>"global"</code>, <code>"local"</code>, <code>"method"</code>, <code>"field"</code>, <code>"upvalue"</code> o <code>""</code> (un <em>string</em> vacío), de acuerdo a cómo fue invocada la función. (Lua usa un <em>string</em> vacío cuando otras opciones no son idóneas.)

</li><li><b><code>nups</code>:</b>
el numero de <em>upvalues</em> de la función.

</li></ul>

<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
lua_Hook lua_gethook (lua_State *L);</pre>


<p>Retorna la función <em>hook</em> actual.

<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p><span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_gethookcount (lua_State *L);</pre>


<p>Retorna el contador de <em>hook</em> actual.

<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_gethookmask (lua_State *L);</pre>


<p>Retorna la máscara del <em>hook</em> actual.

<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>

<pre>
int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>Devuelve información acerca de una función específica o de una invocación de función.


<p>Para obtener información acerca de una invocación de función, el parámetro <code>ar</code> debe ser un registro de activación válido, que haya sido llenado con una llamada previa a
<a href="#lua_getstack"><code>lua_getstack</code></a> o dada como argumento a un <em>hook</em>
(véase <a href="#lua_Hook"><code>lua_Hook</code></a>).


<p>Para obtener información de una función se coloca la misma en la parte superior de la pila
y se comienza el <em>string</em> <code>what</code> con el carácter '<code>></code>'. (En ese caso,
<code>lua_getinfo</code> elimina la función de la parte superior de la pila.) Por ejemplo,
para conocer en qué línea fue definida una función <code>f</code> se puede utilizar el
siguiente código:

<pre>       lua_Debug ar;
       lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* obtiene la 'f' global */
       lua_getinfo(L, "&gt;S", &amp;ar);
       printf("%d\n", ar.linedefined);
</pre>


<p>
Cada carácter en el <em>string</em> <code>what</code> selecciona los campos de la estructura <code>ar</code> que serán rellenados o un valor que será colocado en la parte superior de la pila:

<ul>
<li><b>'<code>n</code>':</b> rellena los campos <code>name</code> y <code>namewhat</code>;
<li><b>'<code>S</code>':</b> rellena los campos <code>source</code>, <code>short_src</code>, <code>linedefined</code>, <code>lastlinedefined</code> y <code>what</code>;
<li><b>'<code>l</code>':</b> rellena el campo <code>currentline</code>;
<li><b>'<code>u</code>':</b> rellena el campo <code>nups</code>;
<li><b>'<code>f</code>':</b> coloca en la pila la función que está ejecutándose al nivel dado;
<li><b>'<code>L</code>':</b> coloca en la pila una tabla cuyos índices son los números de las
líneas que son válidas en la función. (Una <em>línea válida</em> es una línea con algún código
asociado, esto es, una línea donde se puede poner un punto de rotura. Las líneas no válidas
incluyen líneas vacías y comentarios.
</ul>

<p>Esta función devuelve 0 en caso de error (por ejemplo, una opción inválida en
<code>what</code>).

<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>

<pre>
const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);</pre>


<p>Obtiene información acerca de una variable local de un registro de activación dado. El argumento <code>ar</code> debe ser un registro de activación válido que fue rellenado en una llamada previa a <a href="#lua_getstack"><code>lua_getstack</code></a> o dado como argumento a un <em>hook</em> (véase <a href="#lua_Hook"><code>lua_Hook</code></a>). El índice <code>n</code> selecciona qué variable local inspeccionar (1 es el primer argumento o la primera variable local activa, y así sucesivamente, hasta la última variable local activa). <a href="#lua_getlocal"><code>lua_getlocal</code></a> coloca el valor de la variable en la pila y retorna su nombre.

<p>Los nombres de variable que comienzan con '<code>(</code>' (paréntesis de abrir) representan variables internas (variables de control de bucle, variables temporales y variables locales de funciones C).

<p>Retorna <code>NULL</code> (y no coloca nada en la pila) cuando el índice es mayor que el número de variables locales activas.

<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>


<p>Obtiene información acerca de la pila en ejecución del intérprete.

<p>Esta función rellena partes de una estructura <a href="#lua_debug"><code>lua_debug</code></a> con una identificación del <em>registro de activación</em> de la función que se está ejecutando al nivel dado. Nivel 0 es la función actualmente en ejecución, mientras que el nivel <em>n+1</em> es la función que ha invocado a la del nivel <em>n</em>. Cuando no hay errores, <a href="#lua_getstack"><code>lua_getstack</code></a> retorna 1; cuando se llama con un nivel mayor que el tamaño de la pila retorna 0.

<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>

<pre>
const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>


<p>Obtiene información acerca de un <em>upavalue</em> de una instancia. (Para las funciones Lua los <em>upvalues</em> son variables locales externas a la función que las usa, y que, por consiguiente, están incluidas en su instancia.) <a href="#lua_getupvalue"><code>lua_getupvalue</code></a> obtiene el índice <code>n</code> de un <em>upvalue</em>, coloca su valor en la pila y retorna su nombre. <code>funcindex</code> apunta hacia la instancia en la pila. (Los <em>upvalues</em> no siguen un orden particular, puesto que están activos a lo largo de toda la función. Por tanto, están numerados siguiendo un orden arbitrario.)

<p>Retorna <code>NULL</code> (y no coloca nada en la pila) cuando el índice es mayor que el número de <em>upvalues</em>. Para funciones C esta función usa el <em>string</em> vacío <code>""</code> como nombre para todos los <em>upvalues</em>.

<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>


<p>Tipo para funciones <em>hook</em> de depuración.

<p>Cada vez que se invoca un <em>hook</em> su argumento <code>ar</code> tiene en su campo <code>event</code> el evento que ha activado el <em>hook</em>. Lua identifica estos eventos con las siguientes constantes: <code>LUA_HOOKCALL</code>, <code>LUA_HOOKRET</code>, <code>LUA_HOOKTAILRET</code>, <code>LUA_HOOKLINE</code> y <code>LUA_HOOKCOUNT</code>. Además, para eventos de línea, también se establece el campo <code>currentline</code>. Para obtener el valor de algún otro campo en <code>ar</code>, el <em>hook</em> debe invocar a <a href="#lua_getinfo"><code>lua_getinfo</code></a>. Para eventos de retorno, <code>event</code> puede ser <code>LUA_HOOKRET</code>, el valor normal, o <code>LUA_HOOKTAILRET</code>. En el último caso, Lua está simulando un retorno de una función que ha hecho una llamada de cola; en este caso, es inútil llamar a <a href="#lua_getinfo"><code>lua_getinfo</code></a>.

<p>Mientras Lua está ejecutando un <em>hook</em>, deshabilita otras llamadas a <em>hooks</em>. Por tanto, si un <em>hook</em> llama de nuevo a Lua para ejecutar una función o un <em>chunk</em> entonces esa ejecución ocurre sin ninguna llamada a <em>hooks</em>.

<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>


<p>Establece la función <em>hook</em> de depuración.

<p><code>func</code> es la función <em>hook</em>. <code>mask</code> especifica en qué eventos debe ser llamado el <em>hook</em>: se forma mediante la operación "or" aplicada a los bits de las constantes <code>LUA_MASKCALL</code>, <code>LUA_MASKRET</code>, <code>LUA_MASKLINE</code>, y <code>LUA_MASKCOUNT</code>. El argumento <code>count</code> sólo tiene sentido cuando la máscara incluye <code>LUA_MASKCOUNT</code>. Para cada evento, el <em>hook</em> es invocado como se explica a continuación:
<ul>
<li><b>El hook tipo "call"</b> es invocado cuando el intérprete llama a una función. El <em>hook</em> es invocado justo después de que Lua entre en la nueva función, antes de que la función tome sus argumentos.
</li><li><b>El hook de tipo "return"</b> es invocado cuando el intérprete retorna desde una función. El <em>hook</em> es invocado justo antes de que Lua deje la función. No se tiene acceso a los valores retornados por la función.
</li><li><b>El hook tipo "line"</b> es invocado cuando el intérprete va a comenzar la ejecución de una nueva línea de código, o cuando salta hacia atrás en el código (incluso en la misma línea). (Este evento sólo ocurre cuando Lua está ejecutando una función Lua.)
</li><li><b>El hook tipo "count"</b> es invocado después de que el intérprete ejecute un número de instrucciones igual a <code>count</code>. (Este evento sólo ocurre cuando Lua está ejecutando una función Lua.)
</li></ul>

<p>Un <em>hook</em> se deshabilita estableciendo <code>mask</code> a cero.

<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, <em>-</em>]</span>

<pre>
const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);</pre>


<p>Establece el valor de una variable local de un registro de activación dado. Los argumentos <code>ar</code> y <code>n</code> son como los de <a href="#lua_getlocal"><code>lua_getlocal</code></a>. <a href="#lua_setlocal"><code>lua_setlocal</code></a> asigna el valor en la parte superior de la pila a la variable y retorna su nombre. También elimina de la pila su valor.

<p>Retorna <code>NULL</code> (y no hace nada con la pila) cuando el índice es mayor que el número de variables locales activas.

<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, <em>-</em>]</span>

<pre>
const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>


<p>Establece el valor de un <em>upvalue</em> de una instancia. Los argumentos <code>funcindex</code> y <code>n</code> son como los de <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>. Asigna el valor que está en la parte superior de la pila al <em>upvalue</em> y retorna su nombre. También elimina de la pila el valor.

<p>Retorna <code>NULL</code> (y no hace nada con la pila) cuando
el índice es mayor que el número de <em>upavalues</em>.

<p>
<h1>4 - <a name="4">La biblioteca auxiliar</a></h1>

<p>La <em>biblioteca auxiliar</em> proporciona varias funciones convenientes para realizar la interface de C con Lua. Mientras que la API básica proporciona las funciones primitivas para todas las interaciones entre C y Lua, la biblioteca auxiliar proporciona funciones de alto nivel para algunas tareas comunes.

<p>Todas las funciones de la biblioteca auxiliar están definidas en el fichero de cabecera <code>lauxlib.h</code> y llevan el prefijo <code>luaL_</code>.

<p>Todas ellas están construidas encima de la API básica así que realmente no proporcionan nada nuevo que no pueda ser realizado con la API.

<p>Algunas funciones en la biblioteca auxiliar son usadas para verificar argumentos de funciones C. Sus nombres son siempre <code>luaL_check*</code> o <code>luaL_opt*</code>. Todas estas funciones activan un error si la verificación no se satisface. Debido a que el mensaje de error se formatea para los argumentos (por ejemplo, <code>"bad argument #1"</code>), no se deberían usar estas funciones para otros valores de la pila.

<p><a name="4.1"></a><h2>4.1 - Funciones y tipos</h2>

<p>Aquí tenemos la lista de todas las funciones y tipos de la biblioteca auxiliar por orden alfabético.

<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>

<pre>
void luaL_addchar (luaL_Buffer *B, char c);</pre>


<p>Añade el carácter <code>c</code> al <em>buffer</em> <code>B</code> (véase <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).

<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>

<pre>
void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>


<p>Añade el <em>string</em> al que apunta <code>s</code> con longitud <code>l</code> al <em>buffer</em> <code>B</code> (véase <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>). El <em>string</em> puede contener ceros.

<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>

<pre>
void luaL_addsize (luaL_Buffer *B, size_t n);</pre>


<p>Añade un <em>string</em> de longitud <code>n</code> previamente copiado en el área del <em>buffer</em> (véase <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>) al <em>buffer</em> <code>B</code> (véase <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).

<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>

<pre>
void luaL_addstring (luaL_Buffer *B, const char *s);</pre>


<p>Añade un <em>string</em> terminado en cero al que apunta <code>s</code> al <em>buffer</em> <code>B</code> (véase <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>). El <em>string</em> no puede contener ceros.

<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>

<pre>
void luaL_addvalue (luaL_Buffer *B);</pre>


<p>Añade el valor situado en la parte superior de la pila al <em>buffer</em> <code>B</code> (véase <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>), eliminándolo de la pila.

<p>Ésta es la única función asociada a los <em>buffers</em> de <em>string</em> que puede (y debe) ser invocada con un elemento extra en la pila, que es el valor que debe ser añadido al <em>buffer</em>.

<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
void luaL_argcheck (lua_State *L,
                    int cond,
                    int narg,
                    const char *extramsg);</pre>


<p>Verifica si <code>cond</code> es verdadero. Si no es así activa un error con el mensaje
<pre>    "bad argument #&lt;numarg&gt; to &lt;func&gt; (&lt;extramsg&gt;)"
</pre>
donde <code>func</code> es recuperado de la pila de llamada.

<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
int luaL_argerror (lua_State *L, int narg, const char *extramsg);</pre>


<p>Activa un error con el mensaje
<pre>    "bad argument #&lt;numarg&gt; to &lt;func&gt; (&lt;extramsg&gt;)"</pre>
donde <code>func</code> es recuperado de la pila de llamada.

<p>Esta función nunca retorna, pero es corriente usarla en funciones C 
en la forma <code>return luaL_argerror(args)</code>.

<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>
typedef struct luaL_Buffer luaL_Buffer;</pre>


<p>Tipo para un <em>buffer</em> de <em>string</em>.

<p>Un <em>buffer</em> de <em>string</em> permite al código en C construir a trozos <em>strings</em> de Lua. Su metodología de uso es como sigue:
<ul>
<li> Primero se declara una variable <code>b</code> de tipo <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.
</li><li> Luego se inicializa la misma con una llamada a <code>luaL_buffinit(L, &amp;b)</code>.
</li><li> Entonces se añaden las piezas del <em>string</em> al <em>buffer</em>, invocando alguna de las funciones <code>luaL_add*</code>.
</li><li> Se finaliza llamando a <code>luaL_pushresult(&amp;b)</code>. Esta llamada deja el <em>string</em> final en la parte superior de la pila.
</li></ul>

<p>Durante su operación normal, un <em>buffer</em> de <em>strings</em> usa un número variable de posiciones en la pila. Así, mientras se está usando el <em>buffer</em>, no se puede asumir que se conoce la posición de la parte superior de la pila. Se puede usar la pila entre llamadas sucesivas a las operaciones de <em>buffer</em> siempre que su uso esté <em>equilibrado</em>; esto es, cuando se invoca una operación con el <em>buffer</em>, la pila está al mismo nivel en el que estaba inmediatamente antes de la operación previa con el <em>buffer</em>. (La única excepción a esta regla es <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>.) Después de llamar a <a href="#luaL_pushresult"><code>luaL_pushresult</code></a> la pila está de nuevo en el mismo nivel que tenía cuando el <em>buffer</em> fue inicializado, más el <em>string</em> final en su parte superior.

<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>

<pre>
void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>


<p>Inicializa un <em>buffer</em> <code>B</code>. Esta función no reserva ningún espacio nuevo de memoria; el <em>buffer</em> debe ser declarado como variable (véase <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).

<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>

<pre>
int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>


<p>Invoca un metamétodo.

<p>Si el objeto con índice <code>obj</code> tiene una metatabla y ésta tiene un campo <code>e</code>, esta función llama a este campo y le pasa el objeto como único argumento. En este caso la función retorna 1 y coloca en la pila el valor devuelto por la llamada. Si no hay metatabla o no hay metamétodo la función retorna 0 (sin colocar ningún valor en la pila).

<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
void luaL_checkany (lua_State *L, int narg);</pre>


<p>Verifica si la función tiene un argumento de algún tipo (incluyendo <b>nil</b>) en la posición <code>narg</code>.

<hr><h3><a name="luaL_checkint"><code>luaL_checkint</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
int luaL_checkint (lua_State *L, int narg);</pre>


<p>Verifica si el argumento <code>narg</code> de la función es un número y retorna este número como <code>int</code> (realizando un <em>cast</em> en C).

<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
lua_Integer luaL_checkinteger (lua_State *L, int narg);</pre>


<p>Verifica si el argumento <code>narg</code> de la función es un número y lo retorna como tipo <a href="#lua_Integer"><code>lua_Integer</code></a>.

<hr><h3><a name="luaL_checklong"><code>luaL_checklong</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
long luaL_checklong (lua_State *L, int narg);</pre>


<p>Verifica si el argumento <code>narg</code> de la función es un número y lo retorna como <code>long</code> (realizando un <em>cast</em> en C).

<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
const char *luaL_checklstring (lua_State *L, int narg, size_t *l);</pre>


<p>Verifica si el argumento <code>narg</code> de la función es un <em>string</em> y retorna el mismo; si <code>l</code> no es <code>NULL</code> coloca la longitud del <em>string</em> en <code>*l</code>.

<p>
Esta función usa <a href="#lua_tolstring"><code>lua_tolstring</code></a> para
obtener su resultado, por lo que todas las conversiones y precauciones asociados
a esa función se aplican aquí.

<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p><span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
lua_Number luaL_checknumber (lua_State *L, int narg);</pre>


<p>Verifica si el argumento <code>narg</code> de la función es un número y retorna el mismo.

<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p><span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
int luaL_checkoption (lua_State *L,
                      int narg,
                      const char *def,
                      const char *const lst[]);</pre>


<p>Verifica si el argumento <code>narg</code> de la función es un <em>string</em> y busca éste en el <em>array</em> <code>lst</code> (que debe estar terminado con NULL). Retorna el índice en el <em>array</em> donde se encontró el <em>string</em>. Activa un error si el argumento no es un <em>string</em> o si no pudo ser encontrado el <em>string</em>.

<p>Si <code>def</code> no es <code>NULL</code>, se usa <code>def</code> como valor por defecto cuando la función no tiene un argumento <code>narg</code> o si este argumento es <b>nil</b>.


<p>Ésta es una función útil para hacer corresponder <em>strings</em> con enumeraciones de C. La convención normal en las bibliotecas de Lua es usar <em>strings</em> en lugar de números para seleccionar opciones.

<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>


<p>Incrementa el tamaño de la pila a <code>top + sz</code> elementos, activando un error si la pila no puede crecer hasta ese tamaño. <code>msg</code> es un texto adicional que iría en el mensaje de error.

<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p><span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
const char *luaL_checkstring (lua_State *L, int narg);</pre>


<p>Verifica si el argumento <code>narg</code> de la función es un <em>string</em> y retorna éste.

<p>
Esta función usa <a href="#lua_tolstring"><code>lua_tolstring</code></a> para
obtener su resultado, por lo que todas las conversiones y precauciones asociados
a esa función se aplican aquí.


<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
void luaL_checktype (lua_State *L, int narg, int t);</pre>


<p>Verifica si el argumento <code>narg</code> de la función tiene tipo <code>t</code>.

<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
void *luaL_checkudata (lua_State *L, int narg, const char *tname);</pre>


<p>Verifica si el argumento <code>narg</code> de la función es un <em>userdata</em> del tipo <code>tname</code> (véase <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).

<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>

<pre>
int luaL_dofile (lua_State *L, const char *filename);</pre>


<p>Carga y ejecuta el fichero dado. Está definida en una macro:

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre>

<p>
Devuelve 0 si no hay errores ó 1 en caso de error.

<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>

<pre>
int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
Carga y ejecuta el <em>string</em> dado. Está definida en una macro:


<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre>
<p>
Devuelve 0 si no hay errores ó 1 en caso de error.

<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
int luaL_error (lua_State *L, const char *fmt, ...);</pre>


<p>Activa un error. El formato del mensaje está dado por <code>fmt</code> más cualesquiera argumentos extra, siguiendo las mismas reglas de <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>. También añade al principio del mensaje el nombre del fichero y el número de línea donde ocurrió el error, si esta información está disponible.

<p>Esta función nunca retorna, pero es corriente usarla en la forma <code>return luaL_error(args)</code> en funciones C.

<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>m</em>]</span>

<pre>
int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>


<p>Coloca en la parte superior de la pila el campo <code>e</code> de la metatabla del objeto situado en la posición del índice <code>obj</code>. Si el objeto no tiene metatabla o si el objeto no tiene este campo retorna 0 y deja la pila intacta.

<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>

<pre>
void luaL_getmetatable (lua_State *L, const char *tname);</pre>


<p>Coloca en la parte superior de la pila la metatabla asociada con el nombre <code>tname</code> en el registro (véase <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).

<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>



<p>Crea una copia del <em>string</em> <code>s</code> reemplazando cualquier aparición del <em>string</em> <code>p</code> por el <em>string</em> <code>r</code>. Coloca el <em>string</em> resultante en la parte superior de la pila y devuelve su valor.

<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>



<p>Carga un <em>buffer</em> como <em>chunk</em> de Lua. Esta función usa <a href="#lua_load"><code>lua_load</code></a> para cargar el <em>chunk</em> en el <em>buffer</em> apuntado por <code>buff</code> con tamaño <code>sz</code>.

<p>Esta función retorna el mismo resultado que <a href="#lua_load"><code>lua_load</code></a>. <code>name</code> es el nombre del <em>chunk</em>, usado para información de depuración y en los mensajes de error.

<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
int luaL_loadfile (lua_State *L, const char *filename);</pre>


<p>Carga un fichero como <em>chunk</em> de Lua. Esta función usa <a href="#lua_load"><code>lua_load</code></a> para cargar el <em>chunk</em> que está en el fichero <code>filename</code>. Si <code>filename</code> es <code>NULL</code> entonces se carga desde la entrada estándar. La primera línea en el fichero se ignora si comienza por <code>#</code>.

<p>Esta función retorna el mismo resultado que <a href="#lua_load"><code>lua_load</code></a>, pero tiene un código extra de error <code>LUA_ERRFILE</code> si no puede leer o abrir el fichero.

<p>Como <a href="#lua_load"><code>lua_load</code></a> esta función sólo carga el <em>chunk</em> y no lo ejecuta.

<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
int luaL_loadstring (lua_State *L, const char *s);</pre>


<p>Carga un <em>string</em> como <em>chunk</em> de Lua. Esta función usa <a href="#lua_load"><code>lua_load</code></a> para cargar el <em>chunk</em> que está en el <em>string</em> <code>s</code> terminado en un carácter cero.

<p>Esta función retorna el mismo resultado que <a href="#lua_load"><code>lua_load</code></a>.

<p>Como <a href="#lua_load"><code>lua_load</code></a> esta función sólo carga el <em>chunk</em> y no lo ejecuta.

<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
int luaL_newmetatable (lua_State *L, const char *tname);</pre>


<p>Si el registro tiene ya una clave <code>tname</code> retorna 0. En caso contrario crea una nueva tabla que será usada como metatabla del <em>userdata</em>, añadiendo la clave <code>tname</code> al registro, y retornando 1.

<p>En ambos caso coloca en la parte superior de la pila el valor final asociado con <code>tname</code> en el registro.

<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
lua_State *luaL_newstate (void);</pre>


<p>Crea un nuevo estado de Lua, invocando <a href="#lua_newstate"><code>lua_newstate</code></a> con una función de reserva de memoria basada en la función C estándar <code>realloc</code> y estableciendo una función de "pánico" (véase <a href="#lua_atpanic"><code>lua_atpanic</code></a>) que imprime un mensaje en la salida estándar de error en caso de error fatal.

<p>Retorna el nuevo estado o <code>NULL</code> si surgió un error de reserva de memoria.

<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>

<pre>
void luaL_openlibs (lua_State *L);</pre>


<p>Abre todas las bibliotecas estándar de Lua en el estado dado.

<hr><h3><a name="luaL_optint"><code>luaL_optint</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
int luaL_optint (lua_State *L, int narg, int d);</pre>


<p>Si el argumento <code>narg</code> de la función es un número retorna éste como un <code>int</code>. Si este argumento está ausente o es <b>nil</b> retorna <code>d</code>. En otro caso activa un error.

<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
lua_Integer luaL_optinteger (lua_State *L,
                             int narg,
                             lua_Integer d);</pre>


<p>Si el argumento <code>narg</code> de la función es un número retorna el mismo como <a href="#lua_Integer"><code>lua_Integer</code></a>. Si este argumento está ausente o es <b>nil</b> retorna <code>d</code>. En caso contrario activa un error.

<hr><h3><a name="luaL_optlong"><code>luaL_optlong</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
long luaL_optlong (lua_State *L, int narg, long d);</pre>


<p>Si el argumento <code>narg</code> de la función es un número retorna el mismo como <code>long</code>. Si este argumento está ausente o es <b>nil</b> retorna <code>d</code>. En caso contrario activa un error.

<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
const char *luaL_optlstring (lua_State *L,
                             int narg,
                             const char *d,
                             size_t *l);</pre>



<p>Si el argumento <code>narg</code> de la función es un <em>string</em> retorna éste. Si este argumento está ausente o es <b>nil</b> retorna <code>d</code>. En caso contrario activa un error.

<p>Si <code>l</code> no es <code>NULL</code> coloca la longitud del resultado en <code>*l</code>.

<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);</pre>


<p>Si el argumento <code>narg</code> de la función es un número retorna el mismo. Si este argumento está ausente o es <b>nil</b> retorna <code>d</code>. En caso contrario activa un error.

<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
const char *luaL_optstring (lua_State *L,
                            int narg,
                            const char *d);</pre>


<p>Si el argumento <code>narg</code> de la función es un <em>string</em> retorna éste. Si este argumento está ausente o es <b>nil</b> retorna <code>d</code>. En caso contrario activa un error.

<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
char *luaL_prepbuffer (luaL_Buffer *B);</pre>


<p>Retorna una dirección que apunta a un espacio de tamaño <code>LUAL_BUFFERSIZE</code> donde se puede copiar un <em>string</em> para ser añadido al <em>buffer</em> <code>B</code> (véase <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>). Después de copiar el <em>string</em> en este espacio se debe invocar <a href="#luaL_addsize"><code>luaL_addsize</code></a> con el tamaño del <em>string</em> para añadirlo realmente en el <em>buffer</em>.

<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>

<pre>
void luaL_pushresult (luaL_Buffer *B);</pre>


<p>Finaliza el uso del <em>buffer</em> <code>B</code> dejando el <em>string</em> en la parte superior de la pila.

<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>

<pre>
int luaL_ref (lua_State *L, int t);</pre>


<p>Crea y retorna una <em>referencia</em> en la tabla en la posición del índice <code>t</code> para el objeto en la parte superior de la pila (y elimina el mismo de la pila).

<p>Una referencia es una clave entera única. Mientras que no se añadan manualmente claves enteras a la tabla <code>t</code>, <a href="#luaL_ref"><code>luaL_ref</code></a> asegura la unicidad de la clave que retorna. Se puede recuperar un objeto apuntado por la referencia <code>r</code> invocando <code>lua_rawgeti(L, t, r)</code>. La función <a href="#luaL_unref"><code>luaL_unref</code></a> elimina una referencia y su objeto asociado.

<p>Si el objeto en la parte superior de la pila es <b>nil</b>, <a href="#luaL_ref"><code>luaL_ref</code></a> retorna la constante <code>LUA_REFNIL</code>. Está garantizado que la constante <code>LUA_NOREF</code> es diferente de cualquier referencia retornada por <a href="#luaL_ref"><code>luaL_ref</code></a>.

<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>
typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>



<p>Tipo para <em>arrays</em> de funciones para ser registradas por
<a href="#luaL_register"><code>luaL_register</code></a>.
<code>name</code> es el nombre de la función y <code>func</code> es un puntero a la misma.
Cualquier <em>array</em> de <a href="#luaL_Reg"><code>luaL_Reg</code></a> debe finalizar con
una entrada "centinela" en la que tanto <code>name</code> como <code>func</code> son <code>NULL</code>.

<hr><h3><a name="luaL_register"><code>luaL_register</code></a></h3><p>
<span class="apii">[-(0|1), +1, <em>m</em>]</span>

<pre>
void luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);</pre>


<p>Abre una biblioteca.

<p>Cuando se llama con <code>libname</code> igual a <code>NULL</code> simplemente registra todas las funciones de la lista <code>l</code> (véase <a href="#luaL_Reg"><code>luaL_Reg</code></a>) en la tabla que está en la parte superior de la pila.

<p>Cuando se llama con un valor <code>libname</code> no nulo crea una nueva tabla <code>t</code>, establece la misma como valor de la variable global <code>libname</code>, establece la misma como valor de <code>package.loaded[libname]</code> y registra en ella todas las funciones de la lista <code>l</code>. Si existe una tabla en <code>package.loaded[libname]</code> o en la variable <code>libname</code> reutiliza esta tabla en lugar de crear una nueva.

<p>En cualquier caso la función deja la tabla en la parte superior de la pila.

<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
const char *luaL_typename (lua_State *L, int index);</pre>


<p>Retorna el nombre del tipo del valor situado en el índice dado.

<hr><h3><a name="luaL_typerror"><code>luaL_typerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>

<pre>
int luaL_typerror (lua_State *L, int narg, const char *tname);</pre>



<p>Genera un error con un mensaje de la forma:
<pre>    <em>location</em>: bad argument <em>narg</em> to <em>function</em> (<em>tname</em> expected, got <em>rt</em>)
</pre>
donde <em>location</em> está producida por <a href="#luaL_where"><code>luaL_where</code></a>, <em>function</em> es el nombre de la función actual y <em>rt</em> es el nombre del tipo del argumento actual.


<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>

<pre>
void luaL_unref (lua_State *L, int t, int ref);</pre>


<p>Libera la referencia <code>ref</code> de la tabla en el índice <code>t</code> (véase <a href="#luaL_ref"><code>luaL_ref</code></a>). La entrada es eliminada de la tabla, por lo que la memoria reservada para el objeto referido en la misma puede ser liberada. La referencia <code>ref</code> también es liberada para poder ser reutilizada.

<p>Si <code>ref</code> es <code>LUA_NOREF</code> o <code>LUA_REFNIL</code>,
<a href="#luaL_unref"><code>luaL_unref</code></a> no hace nada.

<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>

<pre>
void luaL_where (lua_State *L, int lvl);</pre>


<p>Coloca en la parte superior de la pila un <em>string</em> identificando la posición actual del control en el nivel <code>lvl</code> en la pila de llamada. Típicamente este <em>string</em> tiene el formato:

<pre>       <em>chunkname</em>:<em>currentline</em>:
</pre>
<p>
Nivel 0 es la función actualmente ejecutándose, nivel 1 es la función que llamó a la función actual, etc.

<p>Esta función se usa para construir un prefijo para los mensajes de error.

<p>
<h1>5 - <a name="5">Bibliotecas estándar</a></h1>

<p>Las bibliotecas estándar de Lua proporcionan funciones útiles que están implementadas directamente a través de la API de C. Algunas de estas funciones proveen servicios esenciales al lenguaje (por ejemplo, <a href="#pdf-type"><code>type</code></a> y <a href="#pdf-getmetatable"><code>getmetatable</code></a>); otras proporcionan acceso a servicios "externos" (por ejemplo, I/O); y otras podrían ser implementadas en Lua mismo pero son muy útiles o tienen requerimientos críticos de tiempo de ejecución y merecen una implementación en C (por ejemplo, <code>sort</code>).

<p>Todas las bibliotecas están implementadas a través de la API oficial de C y se proporcionan como módulos separados en C. En estos momentos Lua tiene las siguientes bibliotecas estándar:
<ul>
<li> biblioteca básica;
</li><li> biblioteca de empaquetado;
</li><li> manejo de <em>strings</em>;
</li><li> manejo de tablas;
</li><li> funciones matemáticas (sin, log, etc.);
</li><li> entrada y salida (I/O);
</li><li> interacción con el sistema operativo;
</li><li> utilidades de depuración.
</li></ul>
Excepto para las bibliotecas básica y de empaquetado, cada biblioteca proporciona todas sus funciones como campos de tablas globales o como métodos de sus objetos.

<p>Para tener acceso a estas bibliotecas el programa anfitrión en C debe invocar a <a href="#luaL_openlibs"><code>luaL_openlibs</code></a>, la cual abre todas las bibliotecas estándar. De manera alternativa se pueden abrir individualmente invocando a <code>luaopen_base</code> (la biblioteca básica), <code>luaopen_package</code> (la biblioteca de empaquetado), <code>luaopen_string</code> (la biblioteca de <em>strings</em>), <code>luaopen_table</code> (la biblioteca de tablas), <code>luaopen_math</code> (la biblioteca matemática), <code>luaopen_io</code> (la biblioteca de entrada/salida), <code>luaopen_os</code> (la biblioteca del Sistema Operativo) y <code>luaopen_debug</code> (la biblioteca de depuración). Estas funciones están declaradas en <code>lualib.h</code> y no deberían ser invocadas directamente: se deben llamar como a otra función C cualquiera de Lua, por ejemplo, usando <a href="#lua_call"><code>lua_call</code></a>.

<p><a name="5.1"></a><h2>5.1 - Funciones básicas</h2>

<p>La biblioteca básica proporciona algunas funciones del núcleo de Lua. Si no se desea incluir esta biblioteca en una aplicación se debe analizar cuidadosamente si se necesitan proporcionar implementaciones de algunas de sus utilidades.

<hr><h3><a name="pdf-assert"><code>assert (v [, mensaje])</code></a></h3>


<p>Activa un error cuando el valor de su argumento <code>v</code> es falso (por ejemplo, <b>nil</b> o <b>false</b>); en otro caso retorna todos sus argumentos. <code>mensaje</code> es un mensaje de error; cuando está ausente se utiliza por defecto <code>"assertion failed!"</code>.

<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage (opt [, arg])</code></a></h3>


<p>Esta función es una interface genérica al liberador de memoria. Realiza diversas funciones de acuerdo a su primer argumento, <code>opt</code>:
<ul>
<li><b>"stop":</b> detiene el liberador de memoria.
</li><li><b>"restart":</b> reinicia el liberador de memoria.
</li><li><b>"collect":</b> realiza un ciclo completo de liberación de memoria.
</li><li><b>"count":</b> devuelve la memoria total en uso por Lua (en Kbytes).
</li><li><b>"step":</b> realiza un paso de liberación de memoria. El "tamaño" del paso se controla por <code>arg</code> (valores grandes significan más pasos) de una manera no especificada. Si se desea controlar el tamaño del paso se debe afinar experimentalmente el valor de <code>arg</code>. Devuelve <b>true</b> si el paso acaba un ciclo de liberación.
</li><li><b>"steppause":</b> establece <code>arg</code>/100 como el nuevo valor para la <em>pausa</em> del liberador (véase <a href="#2.10">&sect;2.10</a>).
</li><li><b>"setstepmul":</b> establece <code>arg</code>/100 como el nuevo valor para el <em>multiplicador del paso</em> del liberador (véase <a href="#2.10">&sect;2.10</a>).
</li></ul>

<p><hr><h3><a name="pdf-dofile"><code>dofile (nombre_de_fichero)</code></a></h3>

<p>Abre el fichero con el nombre dado y ejecuta su contenido como un <em>chunk</em> de Lua. Cuando se invoca sin argumentos, <code>dofile</code> ejecuta el contenido de la entrada estándar (<code>stdin</code>). Devuelve todos los valores retornados por el <em>chunk</em>. En caso de error, <code>dofile</code> propaga el error a su invocador (esto es, <code>dofile</code> no se ejecuta en modo protegido).

<hr><h3><a name="pdf-error"><code>error (mensaje [, nivel])</code></a></h3>


Termina la última función protegida llamada, estableciendo <code>mensaje</code> como mensaje de error. La función <code>error</code> nunca retorna.

<p>Normalmente <code>error</code> añade, al comienzo del mensaje, cierta información acerca de la posición del error. El argumento <code>nivel</code> especifica cómo obtener la posición del error. Con nivel 1 (por defecto) la posición del error es donde fue invocada la función <code>error</code>. Nivel 2 apunta el error hacia el lugar en que fue invocada la función que llamó a <code>error</code>; y así sucesivamente. Pasar un valor 0 como nivel evita la adición de la información de la posición al mensaje.

<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>


Una variable global (no una función) que almacena el entorno global (o sea, <code>_G._G = _G</code>). Lua mismo no usa esta variable; cambiar su valor no afecta ningún entorno, ni viceversa. (Úsese <a href="#pdf-setfenv"><code>setfenv</code></a> para cambiar entornos.)

<hr><h3><a name="pdf-getfenv"><code>getfenv ([f])</code></a></h3>


<p>Retorna el entorno actualmente en uso por la función. <code>f</code> puede ser una función Lua o un número que especifica la función a ese nivel de la pila: nivel 1 es la función que invoca a <code>getfenv</code>. Si la función dada no es una función Lua o si <code>f</code> es 0, <code>getfenv</code> retorna el entorno global. El valor por defecto de <code>f</code> es 1.

<hr><h3><a name="pdf-getmetatable"><code>getmetatable (objeto)</code></a></h3>


<p>Si <code>objeto</code> no tiene una metatabla devuelve <b>nil</b>. En otro caso, si la metatabla del objeto tiene un campo <code>"__metatable"</code> retorna el valor asociado, o si no es así retorna la metatabla del objeto dado.

<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>



<p>Retorna tres valores: una función iteradora, la tabla <code>t</code>, y 0, de tal modo que la construcción
<pre>       for i,v in ipairs(t) do <em>bloque</em> end
</pre>
iterará sobre los pares (<code>1,t[1]</code>), (<code>2,t[2]</code>), &middot;&middot;&middot;, hasta la primera clave entera con un valor nil en la tabla.

<hr><h3><a name="pdf-load"><code>load (func [, nombre_de_chunk])</code></a></h3>


<p>Carga un <em>chunk</em> usando la función <code>func</code> para obtener sus partes.

Cada llamada a <code>func</code> debe retornar un <em>string</em> que se concatena con los resultados previos. Un retorno de <b>nil</b> (o no valor) señala el final del <em>chunk</em>.

<p>Si no hay errores retorna el <em>chunk</em> compilado como una función; en otro caso retorna <b>nil</b> más un mensaje de error. El entorno de la función retornada es el global.

<p><code>nombre_de_chunk</code> se utiliza para identificar el <em>chunk</em> en los mensajes de error y para información de depuración.

<hr><h3><a name="pdf-loadfile"><code>loadfile ([nombre_de_fichero])</code></a></h3>



<p>Similar a <a href="#pdf-load"><code>load</code></a>, pero obtiene el <em>chunk</em> del fichero <code>nombre_de_fichero</code> o de la entrada estándar si no se proporciona un nombre.

<hr><h3><a name="pdf-loadstring"><code>loadstring (string [, nombre_de_chunk])</code></a></h3>



<p>Similar a <a href="#pdf-load"><code>load</code></a>, pero obtiene el <em>chunk</em> del <em>string</em> proporcionado.

<p>Para cargar y ejecutar un <em>string</em> dado úsese
<pre>      assert(loadstring(s))()
</pre>

<p>Cuando está ausente, <code>nombre_de_chunk</code> toma por defecto el <em>string</em> dado.

<hr><h3><a name="pdf-next"><code>next (tabla [, índice])</code></a></h3>



<p>Permite al programa recorrer todos los campos de una tabla. Su primer argumento es una tabla y su segundo argumento es un índice en esta tabla. <code>next</code> retorna el siguiente índice de la tabla y su valor asociado. Cuando se invoca con <b>nil</b> como segundo argumento <code>next</code> retorna un índice inicial y su valor asociado. Cuando se invoca con el último índice o con <b>nil</b> en una tabla vacía <code>next</code> retorna <b>nil</b>. Si el segundo argumento está ausente entonces se interpreta como <b>nil</b>. En particular se puede usar <code>next(t)</code> para comprobar si una tabla está vacía.

<p>
El orden en que se enumeran los índices no está especificado, <em>incluso para índices numéricos</em>. (Para recorrer una tabla en orden numérico úsese el <b>for</b> numérico o la función <a href="#pdf-ipairs"><code>ipairs</code></a>.)

<p>El comportamiento de <code>next</code> es <em>indefinido</em> si durante el recorrido se asigna un valor a un campo no existente previamente en la tabla. No obstante se pueden modificar campos existentes. En particular se pueden borrar campos existentes.

<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>Retorna tres valores: la función <a href="#pdf-next"><code>next</code></a>, la tabla <code>t</code>, y <b>nil</b>, por lo que la construcción
<pre>       for k,v in pairs(t) do <em>bloque</em> end
</pre>
iterará sobre todas las parejas clave-valor de la tabla <code>t</code>.

<p>Véase <a href="#pdf-next"><code>next</code></a> para las  precauciones a tomar cuando se modifica la tabla durante las iteraciones. 

<hr><h3><a name="pdf-pcall"><code>pcall (f, arg1, &middot;&middot;&middot;)</code></a></h3>

<p>Invoca la función <code>f</code> con los argumentos dados en modo protegido. Esto significa que ningún error dentro de <code>f</code> se propaga; en su lugar <code>pcall</code> captura el error y retorna un código de estatus. Su primer resultado es el código de estatus (booleano), el cual es verdadero si la llamada tiene éxito sin errores. En ese caso <code>pcall</code> también devuelve todos los resultados de la llamada después del primer resultado. En caso de error <code>pcall</code> retorna <b>false</b> más un mensaje de error.

<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>

Recibe cualquier número de argumentos e imprime sus valores en el fichero estándar de salida (<code>stdout</code>), usando <a href="#pdf-tostring"><code>tostring</code></a> como función para convertir los argumentos a <em>strings</em>. <code>print</code> no está diseñada para salida formateada sino sólo como una manera rápida de mostrar valores, típicamente para la depuración del código. Para salida formateada úsese <a href="#pdf-string.format"><code>string.format</code></a>.

<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>

<p>Verifica si <code>v1</code> es igual a <code>v2</code>,
sin invocar ningún metamétodo. Devuelve un booleano.

<hr><h3><a name="pdf-rawget"><code>rawget (tabla, índice)</code></a></h3>

<p>Obtiene el valor real de <code>tabla[índice]</code> sin invocar ningún metamétodo. <code>tabla</code> debe ser una tabla e <code>índice</code> cualquier valor diferente de <b>nil</b>.

<hr><h3><a name="pdf-rawset"><code>rawset (tabla, índice, valor)</code></a></h3>

<p>Asigna <code>valor</code> a <code>tabla[índice]</code> sin invocar ningún metamétodo. <code>tabla</code> debe ser una tabla, <code>índice</code> cualquier valor diferente de <b>nil</b> y <code>valor</code> un valor cualquiera de Lua.

<hr><h3><a name="pdf-select"><code>select (índice, &middot;&middot;&middot;)</code></a></h3>

<p>Si <code>índice</code> es un número retorna todos los argumentos después del número <code>índice</code>. En otro caso <code>índice</code> debe ser el <em>string</em> <code>"#"</code>, y <code>select</code> retorna el número total de argumentos extra que recibe.

<hr><h3><a name="pdf-setfenv"><code>setfenv (f, tabla)</code></a></h3>



<p>Establece el entorno que va a ser usado por una función. <code>f</code> puede ser una función Lua o un número que especifica la función al nivel de pila: nivel 1 es la función que invoca a <code>setfenv</code>. <code>setfenv</code> retorna la función dada.

<p>Como caso especial, cuando <code>f</code> es 0 <code>setfenv</code> cambia el entorno del proceso que está en ejecución. En este caso <code>setfenv</code> no retorna valores.

<hr><h3><a name="pdf-setmetatable"><code>setmetatable (tabla, metatabla)</code></a></h3>


<p>Establece la metatabla de una tabla dada. (No se puede cambiar la metatabla de otros tipos desde Lua, sino sólo desde C.) Si <code>metatabla</code> es <b>nil</b> entonces se elimina la metatabla de la tabla dada. Si la metatabla original tiene un campo <code>"__metatable"</code> se activa un error.

<p>Esta función retorna <code>tabla</code>.

<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>Intenta convertir su argumento en un número. Si el argumento es ya un número o un <em>string</em> convertible a un número entonces <code>tonumber</code> retorna este número; en otro caso devuelve <b>nil</b>.

<p>Un argumento opcional especifica la base para interpretar el número. La base puede ser cualquier entero entre 2 y 36, ambos inclusive. En bases por encima de 10 la letra '<code>A</code>' (en mayúscula o minúscula) representa 10, '<code>B</code>' representa 11, y así sucesivamente, con '<code>Z</code>' representando 35. En base 10 (por defecto), el número puede tener parte decimal, así como un exponente opcional (véase <a href="#2.1">&sect;2.1</a>). En otras bases sólo se aceptan enteros sin signo.

<hr><h3><a name="pdf-tostring"><code>tostring (e)</code></a></h3>


<p>Recibe un argumento de cualquier tipo y lo convierte en un <em>string</em> con un formato razonable. Para un control completo de cómo se convierten los números, úsese <a href="#pdf-string.format"><code>string.format</code></a>.

<p>Si la metatabla de <code>e</code> tiene un campo <code>"__tostring"</code> entonces <code>tostring</code> invoca al correspondiente valor con <code>e</code> como argumento y usa el resultado de la llamada como su propio resultado.

<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>


<p>Retorna el tipo de su único argumento, codificado como <em>string</em>. Los posibles resultados de esta función son <code>"nil"</code> (un string, no el valor <b>nil</b>), <code>"number"</code>, <code>"string"</code>, <code>"boolean</code>, <code>"table"</code>, <code>"function"</code>, <code>"thread"</code> y <code>"userdata"</code>.

<hr><h3><a name="pdf-unpack"><code>unpack (lista [, i [, j]])</code></a></h3>


<p>Retorna los elementos de una tabla dada. Esta función equivale a
<pre>  return lista[i], lista[i+1], &middot;&middot;&middot;, lista[j]
</pre>
excepto que este código puede ser escrito sólo para un número fijo de elementos. Por defecto <code>i</code> es 1 y <code>j</code> es la longitud de la lista, como se define a través del operador longitud (véase <a href="#2.5.5">&sect;2.5.5</a>).

<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>


<p>Una variable global (no una función) que almacena un <em>string</em> que contiene la versión actual del intérprete. En esta versión de Lua el contenido actual de esta variable es <code>"Lua 5.1"</code>.

<hr><h3><a name="pdf-xpcall"><code>xpcall (f, err)</code></a></h3>


<p>Esta función es similar a <code>pcall</code>, excepto que se puede establecer un manejador de error.

<p><code>xpcall</code> invoca a la función <code>f</code> en modo protegido, usando <code>err</code> como manejador de error. Ningún error dentro de <code>f</code> se propaga; en su lugar <code>xpcall</code> captura el error, llamando a la función <code>err</code> con el objeto de error original, y retorna un código de estatus. Su primer resultado es el código de estatus (un booleano), que es verdadero si la llamada tiene éxito sin errores. En ese caso <code>xpcall</code> también devuelve todos los resultados de la llamada después del primer resultado. En caso de error <code>xpcall</code> retorna <b>false</b> más el resultado de <code>err</code>.

<p><a name="5.2"></a><h2>5.2 - Manejo de co-rutinas</h2>

<p>Las operaciones relacionadas con co-rutinas comprenden una sub-biblioteca de la biblioteca básica y se sitúa en la tabla <code>coroutine</code>. Véase <a href="#2.11">&sect;2.11</a> para una descripción general de las co-rutinas.

<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>Crea una nueva co-rutina con cuerpo <code>f</code>. <code>f</code> debe ser una función Lua. Retorna una nueva co-rutina, un objeto de tipo <code>"thread"</code>.

<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, ···])</code></a></h3>


<p>Comienza o continúa la ejecución de la co-rutina <code>co</code>. La primera vez que se llama a esta función la co-rutina comienza ejecutando su cuerpo. Los valores <code>val1</code>, &middot;&middot;&middot; se pasan como argumentos al cuerpo de la función. Si la co-rutina ha cedido el control del flujo, <code>resume</code> la reinicia; los valores <code>val1</code>, &middot;&middot;&middot; son pasados como resultados de la cesión.

<p>Si la co-rutina se ejecuta sin error <code>resume</code> retorna <b>true</b> más los valores pasados a <code>yield</code> (si la co-rutina realiza la cesión) o los valores retornados por el cuerpo de la función (si la co-rutina acaba). Si existe cualquier error <code>resume</code> retorna <b>false</b> más un mensaje de error.

<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>Retorna la co-rutina en ejecución o <b>nil</b> cuando se invoca desde el proceso principal.

<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>Retorna el estatus de la co-rutina <code>co</code> como un <em>string</em>: <code>"running"</code>, si la co-rutina está en ejecución (esto es, invocó a <code>status</code>); <code>"suspended"</code>, si la co-rutina está suspendida en una llamada a <code>yield</code>, o si todavía no ha comenzado a ejecutarse; <code>"normal"</code> si la co-rutina está activa pero no ejecutándose (esto es, si ha resumido otra co-rutina); y <code>"dead"</code> si la co-rutina ha finalizado su función o si se ha detenido con un error.

<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>

<p>Crea una nueva co-rutina con cuerpo <code>f</code>. <code>f</code> debe ser una función Lua. Retorna una función que resume la co-rutina cada vez que es invocada. Cualquier argumento pasado a la función se comporta como un argumento extra para <code>resume</code>. Retorna los mismos valores devueltos por <code>resume</code>, excepto el primer booleano. En caso de error, éste se propaga.

<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>


<p>Suspende la ejecución de la co-rutina invocante. La co-rutina no puede estar ejecutando una función C, un metamétodo o un iterador. Cualquier argumento de <code>yield</code> es pasado como resultado extra a <code>resume</code>.

<p><a name="5.3"></a><h2>5.3 - Módulos</h2>

<p>La biblioteca de empaquetado proporciona utilidades básicas para cargar y construir módulos en Lua. Exporta dos de sus funciones directamente al entorno global: <a href="#pdf-module"><code>module</code></a> y <a href="#pdf-require"><code>require</code></a>. Las demás se exportan en la tabla <code>package</code>.

<hr><h3><a name="pdf-module"><code>module (nombre [, &middot;&middot;&middot;])</code></a></h3>

<p>Crea un módulo. Si existe una tabla en <code>package.loaded[nombre]</code> ésta es el módulo. En otro caso si existe una tabla global <code>t</code> con el nombre dado ésta es el módulo. Sino, finalmente, crea una nueva tabla <code>t</code> y le da el nombre global de <code>nombre</code> y el valor de <code>package.loaded[nombre]</code>. Esta función también inicializa <code>t._NAME</code> con el nombre dado, <code>t._M</code> con el módulo (<code>t</code> mismo), y <code>t._PACKAGE</code> con el nombre del paquete (el módulo <code>nombre</code> completo menos su último componente; véase más abajo). Para acabar, <code>module</code> establece <code>t</code> como nuevo entorno de la función actual y el nuevo valor de <code>package.loaded[nombre]</code>, de tal manera que <a href="#pdf-require"><code>require</code></a> retorna <code>t</code>.

<p>Si <code>nombre</code> es un nombre compuesto (esto es, uno con componentes separados por puntos) <code>module</code> crea (o reutiliza, si ya existen) tablas para cada componente. Por ejemplo, si <code>nombre</code> es <code>a.b.c</code>, entonces <code>module</code> almacena la tabla módulo en el campo <code>c</code> del campo <code>b</code> de la tabla global <code>a</code>.

<p>Esta función puede recibir argumentos <em>opcionales</em> después del nombre del módulo, donde cada opción es una función que será aplicada sobre el módulo.

<hr><h3><a name="pdf-require"><code>require (nombre)</code></a></h3>


<p>Carga el módulo dado. La función comienza buscando en la tabla <code>package.loaded</code> para determinar si <code>nombre</code> está ya cargado. Si es así entonces <code>require</code> devuelve el valor almacenado en <code>package.loaded[nombre]</code>. En otro caso intenta encontrar un <em>cargador</em> para el módulo.

<p>Para encontrar un cargador, primero <code>require</code> se guía por <code>package.preload[nombre]</code>. Cambiando este <em>array</em>, se cambia la manera que en <code>require</code> busca un módulo. La siguiente explicación está basada en la configuración por defecto de <code>package.loaders</code>.

<p>Primero <code>require</code> mira en <code>package.prelodad[modname]</code>. Si tiene un valor, éste (que debe ser una función) es el cargador. En otro caso <code>require</code> busca un cargador en Lua usando el camino de búsqueda guardado en <code>package.path</code>. Si también esto falla, busca un cargador en C usando el camino almacenado en <code>package.cpath</code>. Si también finalmente esto falla intenta un cargador <em>todo en uno</em> (véase <code>package.loaders</code>).

<p>Una vez que se encontró el cargador, <code>require</code> lo invoca con un único argumento, <code>nombre</code>. Si el cargador retorna un valor, <code>require</code> lo asigna a <code>package.loaded[nombre]</code>. Si el cargador no retorna un valor y no está asignado un valor a <code>package.loaded[nombre]</code>, entonces <code>require</code> asigna <b>true</b> a esta entrada. En cualquier caso, <code>require</code> retorna el valor final de <code>package.loaded[nombre]</code>.

<p>Si existen errores durante la carga o ejecución del módulo en proceso o si no se pudo encontrar un cargador para el módulo, entonces <code>require</code> activa un error.

<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>

<p>El camino de búsqueda usado por <a href="#pdf-require"><code>require</code></a> para buscar un cargador en C.

<p>Lua inicializa este camino <code>package.cpath</code> de la misma manera en que inicializa el camino de Lua <a href="#pdf-package.path"><code>package.path</code></a>, usando la variable de entorno <code>LUA_CPATH</code> (además de otro camino por defecto definido en <code>luaconf.h</code>).

<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>

<p>Una tabla usada por <a href="#pdf-require"><code>require</code></a> para controlar qué módulos están ya cargados. Cuando se solicita un módulo <code>nombre</code> y <code>package.loaded[nombre]</code> no es falso, <a href="#pdf-require"><code>require</code></a> simplemente retorna el valor almacenado.

<hr><h3><a name="pdf-package.loaders"><code>package.loaders</code></a></h3>


<p>Una tabla usada por <a href="#pdf-require"><code>require</code></a>
que controla cómo se cargan los módulos

<p>Cada entrada en esta tabla es una <em>función buscadora</em>. Cuando busca un módulo, <code>require</code> llama a cada uno de esas buscadoras en orden ascendente, con el nombre del módulo (el argumento pasado a <code>require</code>) com único argumento. La función puede retornar otra función (el módulo <em>cargador</em> o un <em>string</em> que explica que no encontró ese módulo (o <b>nil</b> si no tuvo nada que decir). Lua inicializa esta tabla con cuatro funciones.

<p>La primera buscadora simplemente busca un cargador en la tabla <code>package.preload</code>.

<p>La segunda buscadora busca un cargador como biblioteca de Lua, usando el camino de búsqueda guardado en <code>package.path</code>. Un camino es una secuencia de <em>plantillas</em> separadas por puntos y comas (<code>;</code>). En cada plantilla, el buscador cambia cada signo de interrogación que aparezca por <code>nombre_de_fichero</code>, que es el nombre del módulo con cada punto reemplazado por un "separador de directorios" (como "/" en Unix); entonces intentará abrir el fichero con el nombre resultante. Así, por ejemplo, si el el camino de Lua es el <em>string</em>:

<p><pre>    "./?.lua;./?.lc;/usr/local/?/init.lua"</pre>

<p> la búsqueda de un fichero fuente de Lua para el módulo <code>foo</code> intentará abrir los ficheros <code>./foo.lua</code>., <code>./foo.lc</code> y <code>/usr/local/foo/init.lua</code>, en ese orden

<p>La tercera buscadora busca un cargador como biblioteca de C, usando el camino dado en la variable <code>package.cpath</code>. Por ejemplo, si el camino de C es el <em>string</em>:

<p><pre>    "./?.so;./?.dll;/usr/local/?/init.so"</pre>

<p> la buscadora, para el módulo <code>foo</code> intentará abrir los ficheros <code>./foo.so</code>., <code>./foo.dll</code> y <code>/usr/local/foo/init.so</code>, en ese orden. Una vez que encuentre una biblioteca en C, el buscador usa la utilidad de enlace dinámico para enlazar la aplicación con la biblioteca. Entones intenta encontrar la función C dentro de la biblioteca para ser usada como cargador. El nombre de esta función es el <em>string</em> <code>"luaopen_"</code> concatenado con una copia del nombre del módulo donde cada punto es reemplazado por un carácter de subrayado (<code>_</code>). Además, si el nombre del módulo tiene un guión, su prefijo hasta el primer guión incluido se elimina. Por ejemplo, si el nombre del módulo es <code>a.v1-b.c</code> el nombre de función será <code>luaopen_b_c</code>.

<p>La cuarta buscadora intenta un <em>cargador todo-en-uno</em>. Busca en el camino de C una biblioteca con el nombre raiz del módulo dado. Por ejemplo, cuando se pide <code>a.b.c</code> buscará <code>a</code> en una bibliteca C. SI la encuentra busca dentro de ella una función para abrir el submódulo; en nuestro ejemplo, sería <code>luaopen_a_b_c</code>. Con esta utilidad, un paquete puede guardar varios submódulos C en una única biblioteca, con cada submódulo manteniendo su función original de apertura.

<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (nombre_de_biblioteca, nombre_de_func)</code></a></h3>


<p>Enlaza dinámicamente el programa anfitrión con la biblioteca en C <code>nombre_de_biblio</code>. Dentro de esta biblioteca busca una función <code>nombre_de_func</code> y la retorna como una función C. (Por tanto, <code>nombre_de_func</code> debe seguir el protocolo; véase <a href="#lua_CFunction"><code>lua_CFunction</code></a>).

<p>Ésta es una función de bajo nivel. Se salta completamente el sistema de paquetes y de módulos. A diferencia de <a href="#pdf-require"><code>require</code></a>, no realiza ninguna búsqueda en el camino y no añade automáticamente extensiones. <code>nombre_de_biblio</code> debe ser un nombre completo de fichero de la biblioteca en C, incluyendo si es necesario el camino completo y la extensión. <code>nombre_de_func</code> debe ser el nombre exacto exportado por la biblioteca en C (el cual puede depender del compilador de C y del cargador del sistema operativo usados).

<p>Esta función no está soportada por el C ANSI. Por tanto sólo está disponible en algunas plataformas (Windows, Linux, Mac OS X, Solaris, BSD, además de otros sistemas Unix que soportan el estándar <code>dlfcn</code>).

<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>

<p>El camino de búsqueda usado por <a href="#pdf-require"><code>require</code></a> para buscar un cargador de Lua.

<p>Al comienzo Lua inicializa esta variable con el valor de la variable de entorno <code>LUA_PATH</code> o con un camino por defecto definido en <code>luaconf.h</code>, si la variable de entorno no está definida. Si aparece <code>";;"</code> en el valor de la variable de entorno se reemplaza por el camino por defecto.

<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>Una tabla que almacena cargadores para módulos específicos (véase <a href="#pdf-require"><code>require</code></a>).

<hr><h3><a name="pdf-package.seeall"><code>package.seeall (módulo)</code></a></h3>


<p>Establece una metatabla para <code>módulo</code> con su campo <code>__index</code> refiriéndose al entorno global, de tal manera que este módulo hereda los valores del entorno global. Se usa como una opción para la función <a href="#pdf-module"><code>module</code></a>.

<p><a name="5.4"></a><h2>5.4 - Manejo de <em>strings</em></h2>

<p>Esta biblioteca proporciona funciones genéricas de manejo de <em>strings</em>, tales como encontrar y extraer <em>substrings</em> y detectar <a href="#5.4.1">patrones</a>. Cuando se indexa un <em>string</em> en Lua el primer carácter está en la posición 1 (no en 0 como en C). Se permite el uso de índices negativos que se interpretan como indexado hacia atrás, desde el final del <em>string</em>. Por tanto el último carácter del <em>string</em> está en la posición -1, y así sucesivamente.

<p>La biblioteca de <em>strings</em> proporciona todas sus funciones en la tabla <code>string</code>. También establece una metatabla para <em>string</em> donde el campo <code>__index</code> apunta a la misma metatabla. Por tanto, se pueden usar las funciones de manejo de <em>string</em> en un estilo orientado a objetos. Por ejemplo, <code>string.byte(s, i)</code> puede ponerse <code>s:byte(i)</code>.

<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>


<p>Devuelve los códigos numéricos internos de los caracteres <code>s[i]</code>, <code>s[i+1]</code>, &middot;&middot;&middot;, <code>s[j]</code>. El valor por defecto de <code>i</code> es 1; el valor por defecto de <code>j</code> es <code>i</code>.

<p>Téngase en cuenta que los códigos numéricos no son necesariamente portables de unas plataformas a otras.

<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>

<p>Recibe cero o más enteros. Devuelve un <em>string</em> con igual longitud que el número de argumentos, en el que cada carácter tiene un código numérico interno igual a su correspondiente argumento.

<p>Téngase en cuenta que los códigos numéricos no son necesariamente portables de unas plataformas a otras.

<hr><h3><a name="pdf-string.dump"><code>string.dump (function)</code></a></h3>

<p>Devuelve un <em>string</em> que contiene la representación binaria de la función dada, de tal manera que una llamada posterior a <a href="#pdf-loadstring"><code>loadstring</code></a> con este <em>string</em> devuelve una copia de la función. <code>func</code> debe ser una función Lua sin <em>upvalues</em>.

<hr><h3><a name="pdf-string.find"><code>string.find (s, patrón [, inicio [, básica]])</code></a></h3>


<p>Busca la primera aparición de <a href="#5.4.1"><code>patrón</code></a> en el <em>string</em> <code>s</code>. Si la encuentra, <code>find</code> devuelve los índices de <code>s</code> donde comienza y acaba la aparación; en caso contrario retorna <b>nil</b>. Un tercer argumento numérico opcional <code>inicio</code> especifica dónde comenzar la búsqueda; su valor por defecto es 1 y puede ser negativo. Un valor <b>true</b> como cuarto argumento opcional <code>básica</code> desactiva las utilidades de detección de patrones, realizando entonces la función una operación de "búsqueda básica de <em>substring</em>", sin caracteres "mágicos" en el <code>patrón</code>. Téngase en cuenta que si se proporciona el argumento <code>básica</code> también debe proporcionarse el argumento <code>inicio</code>.

<p>Si el patrón tiene <a href="#captures"><em>capturas</em></a> entonces en una detección con éxito se devuelven los valores capturados, después de los dos índices.

<hr><h3><a name="pdf-string.format"><code>string.format (formato, &middot;&middot;&middot;)</code></a></h3>


<p>Devuelve una versión formateada de sus argumentos (en número variable) siguiendo la descripción dada en su primer argumento (<code>formato</code>, que debe ser un <em>string</em>). El <em>string</em> de formato sigue las mismas reglas que la familia de funciones C estándar <code>printf</code>. Las únicas diferencias son que las opciones/modificadores <code>*</code>, <code>l</code>, <code>L</code>, <code>n</code>, <code>p</code>, y <code>h</code> no están soportadas, y que existe una opción extra <code>q</code>. Esta última opción da formato a un <em>string</em> en una forma adecuada para ser leída de manera segura de nuevo por el intérprete de Lua: el <em>string</em> es escrito entre dobles comillas, y todas las dobles comillas, nuevas líneas, ceros y barras inversas del <em>string</em> se sustituyen por las secuencias de escape adecuadas en la escritura. Por ejemplo, la llamada
<pre>       string.format('%q', 'un string con "comillas" y \n nueva línea')
</pre>
producirá el <em>string</em>:
<pre>"un string con \"comillas\" y \
 nueva línea"
</pre>

<p>Las opciones <code>c</code>, <code>d</code>, <code>E</code>, <code>e</code>, <code>f</code>, <code>g</code>, <code>G</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>X</code> y <code>x</code> esperan un número como argumento, mientras que <code>q</code> y <code>s</code> esperan un <em>string</em>.

<p>Esta función no acepta valores de <em>string</em> que contengan caracteres cero, excepto como argumentos de la opción <code>q</code>.

<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, patrón)</code></a></h3>


<p>Devuelve una función iteradora que, cada vez que se invoca, retorna las siguientes <a href="#captures"><em>capturas</em></a> del <a href="#5.4.1"><code>patrón</code></a> en el <em>string</em> <code>s</code>.

<p>Si el <code>patrón</code> no produce capturas entonces la coincidencia completa se devuelve en cada llamada.

<p>Como ejemplo, el siguiente bucle
<pre>  s = "hola mundo desde Lua"
  for w in string.gmatch(s, "%a+") do
    print(w)
  end
</pre>
iterará sobre todas las palabras del <em>string</em> <code>s</code>,
imprimiendo una por línea. El siguiente ejemplo devuelve en forma de tabla todos los pares <code>clave=valor</code> del <em>string</em> dado:
<pre>  t = {}
  s = "desde=mundo, a=Lua"
  for k, v in string.gmatch(s, "(%w+)=(%w+)") do
    t[k] = v
  end
</pre>

<p>Para esta función, un <code>'^'</code> al principio de un patrón no funciona como un ancla, sino que previene la iteración.


<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, patrón, reemplazamiento [, n])</code></a></h3>


<p>Devuelve una copia de <code>s</code> en la que todas (o las <code>n</code> primeras, si se especifica el argumento opcional) las apariciones del <a href="#5.4.1"><code>patrón</code></a> han sido reemplazadas por el <code>reemplazamiento</code> especificado, que puede ser un <em>string</em>, una tabla o una función. <code>gsub</code> también devuelve, como segundo valor, el número total de coincidencias detectadas.

<p>Si <code>reemplazamiento</code> es un <em>string</em> entonces su valor se usa en la sustitución. El carácter <code>%</code> funciona como un carácter de escape: cualquier secuencia en <code>reemplazamiento</code> de la forma <code>%</code><em>n</em>, con <em>n</em> entre 1 y 9, significa el valor de la <a href="#captures"><em>captura</em></a> número <em>n</em> en el <em>substring</em> (véase más abajo). La secuencia <code>%0</code> significa toda la coincidencia. La secuencia <code>%%</code> significa un carácter porcentaje <code>%</code>.

<p>Si <code>reemplazamiento</code> es una tabla entonces en cada captura se devuelve el elemento de la tabla que tiene por clave la primera captura; si el patrón no proporciona ninguna captura entonce toda la coincidencia se utiliza como clave.

<p>Si <code>reemplazamiento</code> es una función entonces la misma es invocada cada vez que exista una captura con todos los <em>substrings capturados</em> pasados como argumentos en el mismo orden; si no existen capturas entonces toda la coincidencia se pasa como un único argumento.

<p>Si el valor devuelto por la tabla o por la llamada a la función es un <em>string</em> o un número, entonces se usa como <em>string</em> de reemplazamiento; en caso contrario si es <b>false</b> o <b>nil</b>, entonces no se realiza ninguna sustitución (esto es, la coincidencia original se mantiene en el <em>string</em>).

<p>He aquí algunos ejemplos:
<pre>   x = string.gsub("hola mundo", "(%w+)", "%1 %1")
   --&gt; x="hola hola mundo mundo"

   x = string.gsub("hola mundo", "%w+", "%0 %0", 1)
   --&gt; x="hola hola mundo"

   x = string.gsub("hola mundo desde Lua", "(%w+)%s*(%w+)", "%2 %1")
   --&gt; x="mundo hola Lua desde"

   x = string.gsub("casa = $HOME, usuario = $USER", "%$(%w+)", os.getenv)
   --&gt; x="casa = /home/roberto, usuario = roberto"

   x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
         return loadstring(s)()
       end)
   --&gt; x="4+5 = 9"

   local t = {nombre="lua", versión="5.1"}
   x = string.gsub("$nombre-$versión.tar.gz", "%$(%w+)", t)
   --&gt; x="lua-5.1.tar.gz"
</pre>

<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>


<p>Recibe un <em>string</em> y devuelve su longitud. El <em>string</em> vacío <code>""</code> tiene longitud 0. Los caracteres cero dentro del <em>string</em> también se cuentan, por lo que <code>"a\000bc\000"</code> tiene longitud 5.

<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>

<p>Recibe un <em>string</em> y devuelve una copia del mismo con todas las letras mayúsculas cambiadas a minúsculas. El resto de los caracteres permanece sin cambios. La definición de letra mayúscula depende del sistema local.

<hr><h3><a name="pdf-string.match"><code>string.match (s, patrón [, inicio])</code></a></h3>


<p>Busca la primera <em>aparición</em> del <a href="#5.4.1"><code>patrón</code></a> en el <em>string</em> <code>s</code>. Si encuentra una, entonces <code>match</code> retorna la <a href="#captures"><em>captura</em></a> del patrón; en caso contrario devuelve <b>nil</b>. Si el <code>patrón</code> no produce ninguna captura entonces se devuelve la coincidencia completa. Un tercer y opcional argumento numérico <code>inicio</code> especifica dónde comenzar la búsqueda; su valor por defecto es 1 y puede ser negativo.

<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n)</code></a></h3>

<p>Devuelve un <em>string</em> que es la concatenación de <code>n</code> copias del <em>string</em> <code>s</code>.

<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>


<p>Devuelve un <em>string</em> que es el original <code>s</code> invertido.

<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>


<p>Retorna el <em>substring</em> de <code>s</code> que comienza en <code>i</code> y continúa hasta <code>j</code>; <code>i</code> y <code>j</code> pueden ser negativos. Si <code>j</code> está ausente entonces se asume que vale <em>-1</em> (equivalente a la longitud del <em>string</em>). En particular, la llamada <code>string.sub(s,1,j)</code> retorna un prefijo de <code>s</code> con longitud <code>j</code>, y <code>string.sub(s, -i)</code> retorna un sufijo de <code>s</code> con longitud <code>i</code>.

<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>

<p>Recibe un <em>string</em> y devuelve una copia del mismo con todas las letras minúsculas cambiadas a mayúsculas. El resto de los caracteres permanece sin cambios. La definición de letra minúscula depende del sistema local.

<h3>5.4.1 - <a name="5.4.1">Patrones</a></h3>

<h4>Clases de caracteres:</h4>

<p><p>
Se usan <em>clases de caracteres</em> para representar conjuntos de caracteres. Están permitidas las siguientes combinaciones para describir una clase de caracteres:
<ul>
<li><b><em>x</em>:</b> (donde <em>x</em> no es uno de los <em>caracteres mágicos</em>
<code>^$()%.[]*+-?</code>) representa el propio caracter <em>x</em>.
</li><li><b><code>.</code>:</b> (un punto) representa cualquier carácter.
</li><li><b><code>%a</code>:</b> representa cualquier letra.
</li><li><b><code>%c</code>:</b> representa cualquier carácter de control.
</li><li><b><code>%d</code>:</b> representa cualquier dígito.
</li><li><b><code>%l</code>:</b> representa cualquier letra minúscula.
</li><li><b><code>%p</code>:</b> representa cualquier carácter de puntuación.
</li><li><b><code>%s</code>:</b> representa cualquier carácter de espacio.
</li><li><b><code>%u</code>:</b> representa cualquier letra mayúscula.
</li><li><b><code>%w</code>:</b> representa cualquier carácter alfanumérico.
</li><li><b><code>%x</code>:</b> representa cualquier dígito hexadecimal.
</li><li><b><code>%z</code>:</b> representa el carácter con valor interno 0 (cero).
</li><li><b><code>%<em>x</em></code>:</b> (donde <em>x</em> es cualquier carácter no alfanumérico) 
representa el carácter <em>x</em>. Ésta es la manera estándar de "escapar" los caracteres mágicos. Cualquier caracter de puntuación (incluso los no mágicos) pueden ser precedidos por un signo de porcentaje '<code>%</code>' cuando se quieran representarse a sí mismos en el patrón.

<p></li><li><b><code>[<em>conjunto</em>]</code>:</b>
representa la clase que es la unión de todos los caracteres en el <em>conjunto</em>. Un rango de caracteres puede ser especificado separando el carácter del principio y del final mediante un guión '<code>-</code>'. Todas las clases del tipo <code>%</code><em>x</em> descritas más arriba pueden ser también utilizadas como componentes del <em>conjunto</em>. Todos los otros caracteres en el <em>conjunto</em> se representan a sí mismos. Por ejemplo, <code>[%w_]</code> (o <code>[_%w]</code>) representa cualquier carácter alfanumérico o el subrayado, <code>[0-7]</code> representa un dígito octal, y <code>[0-7%l%-]</code> representa un dígito octal, una letra minúscula o el carácter '<code>-</code>'.

<p>La interacción entre los rangos y las clases no está definida. Por tanto, patrones como <code>[%a-z]</code> o <code>[a-%%]</code> carecen de significado.

<p></li><li><b><code>[^<em>conjunto</em>]</code>:</b>
representa el complemento de <em>conjunto</em>, donde <em>conjunto</em> se interpreta como se ha indicado más arriba. </li></ul> Para todas las clases representadas por letras simples (<code>%a</code>, <code>%c</code>, etc.) las correspondientes letras mayúsculas representan la clase complementaria. Por ejemplo, <code>%S</code> representa cualquier carácter no espacio.

<p>Las definiciones de letra, espacio y otros grupos de caracteres dependen del sistema local. En particular, la clase <code>[a-z]</code> puede no ser equivalente a <code>%l</code>.


<h4>Elementos de un patrón</h4>

<p>
Cada <em>elemento de un patrón</em> puede ser
<ul>
<li> 
una clase de carácter simple, que equivale a cualquier carácter simple de la clase;
</li><li> 
una clase de carácter simple seguida por '<code>*</code>', que equivale a 0 ó más repeticiones de los caracteres de la clase. Estos elementos de repetición siempre equivaldrán a la secuencia de caracteres más larga posible;
</li><li> un clase de carácter simple seguida por '<code>+</code>', que equivale a 1 ó más repeticiones de los caracteres de la clase. Estos elementos de repetición siempre equivaldrán a la secuencia de caracteres más larga posible;
</li><li> 
un clase de carácter simple seguida por '<code>-</code>', que también equivale a 0 ó más repeticiones de los caracteres de la clase. Al contrario que '<code>*</code>', Estos elementos de repetición siempre equivaldrán a la secuencia de caracteres más <em>corta</em> posible;
</li><li> 
una clase de carácter simple seguida por '<code>?</code>', que equivale a 0 ó 1 apariciones de un carácter de la clase;
</li><li> 
<code>%</code><em>n</em>, para <em>n</em> entre 1 y 9; este elemento equivale a un <em>substring</em> igual a la <a href="#captures">captura</a> número <em>n</em>;
</li><li> 
<code>%b</code><em>xy</em>, donde <em>x</em> e <em>y</em> son dos caracteres diferentes; este elemento equivale a <em>strings</em> que comienzan con <em>x</em>, finalizan con <em>y</em>,  estando <em>equilibrados</em> <em>x</em> e <em>y</em>. Esto significa que, iniciando un contador a 0, si se lee el <em>string</em> de izquierda a derecha, sumando <em>+1</em> por cada <em>x</em> que aparezca y <em>-1</em> por cada <em>y</em>, el <em>y</em> final es el primero donde el contador alcanza 0. Por ejemplo, el elemento <code>%b()</code> equivale a una expresión con paréntesis emparejados.
</li></ul>

<h4>Patrón</h4>

<p>
Un <em>patrón</em> es una secuencia de elementos de patrón. Un '<code>^</code>' al comienzo de un patrón ancla la búsqueda del patrón al comienzo del <em>string</em> en el que se produce la búsqueda. Un '<code>$</code>' al final de un patrón ancla la búsqueda del patrón al final del <em>string</em> en el que se produce la búsqueda. En otras posiciones '<code>^</code>' y '<code>$</code>' no poseen un significado especial y se representan a sí mismos.

<p><a name="captures"></a><h4>Capturas</h4>

<p>Un <a href="#5.4.1">patrón</a> puede contener subpatrones encerrados entre paréntesis que describen <em>capturas</em>. Cuando sucede una coincidencia entre un patrón y un <em>string</em> dado, los <em>substrings</em> que concuerdan con lo indicado entre paréntesis en el patrón, son almacenados (<em>capturados</em>) para uso futuro. Las capturas son numeradas de acuerdo a sus paréntesis izquierdos. Por ejemplo, en el patrón <code>"(a*(.)%w(%s*))"</code>, la parte del <em>string</em> que concuerda con <code>"a*(.)%w(%s*)"</code> se guarda en la primera captura (y por tanto tiene número 1); el carácter que concuerda con <code>"."</code> se captura con el número 2, y la parte que concuerda con <code>"%s*"</code> tiene el número 3.

<p>Como caso especial, la captura vacía <code>()</code> retorna la posición actual en el <em>string</em> (un número). Por ejemplo, si se aplica el patrón <code>"()aa()"</code> al <em>string</em> <code>"flaaap"</code>, dará dos capturas: 3 y 5.

<p>Un patrón no puede contener caracteres cero. Úsese <code>%z</code> en su lugar.

<p><a name="5.5"></a><h2>5.5 - Manejo de tablas</h2>

Esta biblioteca proporciona funciones genéricas para manejo de tablas. Todas estas funciones están definidas dentro de la tabla <code>table</code>.

<p>La mayoría de las funciones en la biblioteca de tablas asume que las mismas representan <em>arrays</em> o listas (o sea, están indexadas numéricamente). Para estas funciones, cuando hablamos de la "longitud" de una tabla queremos decir el resultado del operador longitud (<code>#</code>).

<hr><h3><a name="pdf-table.concat"><code>table.concat (tabla [, separador [, i [, j]]])</code></a></h3>


Dado una table donde todos sus elementos son <em>strings</em> o números devuelve <code>tabla[i]..separador..tabla[i+1] &middot;&middot;&middot; separador..tabla[j]</code>. El valor por defecto de <code>separador</code> es el <em>string</em> vacío, el valor por defecto de <code>i</code> es 1 y el valor por defecto de <code>j</code> es la longitud de la tabla. Si <code>i</code> es mayor que <code>j</code>, la función devuelve un <em>string</em> vacío.

<hr><h3><a name="pdf-table.insert"><code>table.insert (tabla, [posición,] valor)</code></a></h3>


<p>Inserta el elemento <code>valor</code> en la <code>posición</code> dada en la <code>tabla</code>, desplazando hacia adelante otros elementos para abrir hueco, si es necesario. El valor por defecto de <code>posición</code> es <code>n+1</code>, donde <code>n = #tabla</code> es la longitud de la tabla (véase <a href="#2.5.5">&sect;2.5.5</a>), de tal manera que <code>table.insert(t,x)</code> inserta <code>x</code> al final de la tabla <code>t</code>.

<hr><h3><a name="pdf-table.maxn"><code>table.maxn (tabla)</code></a></h3>


<p>Devuelve el mayor índice numérico positivo de una tabla dada o cero si la tabla no tiene índices numéricos positivos. (Para hacer su trabajo esta función realiza un barrido lineal de la tabla completa.)

<hr><h3><a name="pdf-table.remove"><code>table.remove (tabla [, posición])</code></a></h3>

<p>Elimina de <code>tabla</code> el elemento situado en la <code>posición</code> dada, desplazando hacia atrás otros elementos para cerrar espacio, si es necesario. Devuelve el valor del elemento eliminado. El valor por defecto de <code>posición</code> es <code>n</code>, donde <code>n</code> es la longitud de la tabla, por lo que la llamada <code>table.remove(t)</code> elimina el último elemento de la tabla <code>t</code>.

<hr><h3><a name="pdf-table.sort"><code>table.sort (tabla [, comparador])</code></a></h3>

Ordena los elementos de la tabla en un orden dado <em>modificando la propia tabla</em>, desde <code>table[1]</code> hasta <code>table[n]</code>, donde <code>n</code> es la longitud de la tabla. Si se proporciona el argumento <code>comparador</code> éste debe ser una función que recibe dos elementos de la tabla y devuelve verdadero cuando el primero es menor que el segundo (por lo que <code>not comparador(a[i+1],a[i])</code> será verdadero después de la ordenación). Si no se proporciona una función <code>comparador</code> entonces se usa el operador estándar <code>&lt;</code> de Lua.

<p>El algoritmo de ordenación no es estable; esto es, los elementos considerados iguales por la ordenación dada pueden sufrir cambios de orden relativos después de la ordenación.

<p><a name="5.6"></a><h2>5.6 - Funciones matemáticas</h2>

<p>Esta biblioteca es una interface a la biblioteca matemática estándar de C. Proporciona todas sus funciones dentro de la tabla <code>math</code>.


<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p>
Devuelve el valor absoluto de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p>
Devuelve el arco coseno de <code>x</code> (en radianes).




<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>

<p>
Devuelve el arco seno de <code>x</code> (en radianes).




<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (x)</code></a></h3>


<p>
Devuelve el arco tangente de <code>x</code> (en radianes).




<p>

<hr><h3><a name="pdf-math.atan2"><code>math.atan2 (y, x)</code></a></h3>


<p>
Devuelve el arco tangente de <code>y/x</code> (en radianes),
pero usa los signos de ambos argumentos para determinar el cuadrante del resultado.
(También maneja correctamente el caso en que <code>x</code> es cero.)




<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p>
Devuelve el menor entero mayor o igual que <code>x</code>.




<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p>
Devuelve el coseno de <code>x</code> (se asume que está en radianes).




<p>
<hr><h3><a name="pdf-math.cosh"><code>math.cosh (x)</code></a></h3>


<p>
Devuelve el coseno hiperbólico de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>
Devuelve en grados sexagesimales el valor de <code>x</code> (dado en radianes).



<p>

<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>
Devuelve el valor de <em>e<sup>x</sup></em>.




<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p>
Devuelve el mayor entero menor o igual que <code>x</code>.





<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>
Devuelve el resto de la división de <code>x</code> por <code>y</code>.




<p>
<hr><h3><a name="pdf-math.frexp"><code>math.frexp (x)</code></a></h3>


<p>
Devuelve <code>m</code> y <code>e</code> tales que <em>x = m 2<sup>e</sup></em>,
<code>e</code> es un entero y el valor absoluto de <code>m</code>
está en el intervalo <em>[0.5, 1)</em>

(o cero cuando <code>x</code> es cero).




<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>
El valor <code>HUGE_VAL</code>, un valor más grande o igual que otro valor numérico cualquiera.



<p>
<hr><h3><a name="pdf-math.ldexp"><code>math.ldexp (m, e)</code></a></h3>

<p>
Devuelve <em>m 2<sup>e</sup></em> (<code>e</code> debe ser un entero).




<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x)</code></a></h3>


<p>
Devuelve el logaritmo natural de <code>x</code>.





<p>
<hr><h3><a name="pdf-math.log10"><code>math.log10 (x)</code></a></h3>


<p>
Devuelve el logaritmo decimal (base 10) de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Devuelve el mayor valor de entre sus argumentos.



<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Devuelve el menor valor de entre sus argumentos.




<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p>
Devuelve dos números, las partes entera y fraccional de <code>x</code> .



<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p>
El valor de <em>pi</em>.




<p>
<hr><h3><a name="pdf-math.pow"><code>math.pow (x, y)</code></a></h3>


<p>
Devuelve <em>x<sup>y</sup></em>.
(Se puede también usar la expresión <code>x^y</code> para calcular este valor.)





<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>
Devuelve en radianes el valor del ángulo <code>x</code> (dado en grados sexagesimales).




<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>
Esta función es un interface a <code>rand</code>, generador simple de números pseudo-aleatorios
proporcionado por el ANSI&nbsp;C. (Sin garantías de sus propiedades estadísticas.)


<p>
Cuando se invoca sin argumentos devuelve un número pseudoaleatorio real uniforme en el rango <code>[0,1)</code>. Cuando se invoca con un número entero <code>m</code>, <code>math.random</code> devuelve un número pseudoaleatorio entero uniforme en el rango <code>[1, m]</code>. Cuando se invoca con dos argumentos <code>m</code> y <code>n</code> enteros, <code>math.random</code> devuelve un número pseudoaleatorio entero uniforme en el rango <code>[m, n]</code>.


<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>


<p>
Establece <code>x</code> como "semilla" para el generador de números pseudoaleatorios: iguales semillas producen iguales secuencias de números.



<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p>Devuelve el seno de <code>x</code> (se asume que está en radianes).





<p>
<hr><h3><a name="pdf-math.sinh"><code>math.sinh (x)</code></a></h3>


<p>
Devuelve el seno hiperbólico de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p>
Devuelve la raiz cuadrada de <code>x</code>.
(Se puede usar también la expresión <code>x^0.5</code> para calcular este valor.)





<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p>
Devuelve la tangente de <code>x</code> (se asume que está en radianes).




<p>
<hr><h3><a name="pdf-math.tanh"><code>math.tanh (x)</code></a></h3>


<p>
Devuelve la tangente hiperbólica de <code>x</code>.



<p><a name="5.7"></a><h2>5.7 - Utilidades de entrada/salida</h2>

<p>La biblioteca de entrada/salida (I/O de sus siglas en inglés) proporciona dos estilos diferentes de manejo de ficheros.  El primero de ellos usa descriptores de fichero implícitos; esto es, existen dos ficheros por defecto, uno de entrada y otro de salida, y las operaciones se realizan sobre éstos.  El segundo estilo usa descriptores de fichero explícitos.

<p>Cuando se usan descriptores implícitos todas las operaciones soportadas están en la tabla <code>io</code>. Cuando se usan descriptores explícitos, la operación <a href="#pdf-io.open"><code>io.open</code></a> devuelve un descriptor de fichero y todas las operaciones se proporcionan como métodos asociados al descriptor.

<p>La tabla <code>io</code> también proporciona tres descriptores de fichero predefinidos con sus significados usuales en C: 
<a name="pdf-io.stdin"><code>io.stdin</code></a>, <a name="pdf-io.stdout"><code>io.stdout</code></a> e <a name="pdf-io.stderr"><code>io.stderr</code></a>.
La biblioteca de entrada/salida nunca cierra esos ficheros.

<p>A no ser que se especifique, todas las funciones de entrada/salida devuelven <b>nil</b> en caso de fallo (más un mensaje de error como segundo resultado y un código de error dependiente del sistema como un tercer resultado) y valores diferentes de <b>nil</b> si hay éxito.

<hr><h3><a name="pdf-io.close"><code>io.close ([descriptor_de_fichero])</code></a></h3>



<p>Equivalente a <code>descriptor_de_fichero:close()</code>. Sin argumento cierra el fichero de salida por defecto.

<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>


<p>Equivalente a <code>descriptor_de_fichero:flush</code> aplicado al fichero de salida por defecto.

<hr><h3><a name="pdf-io.input"><code>io.input ([descriptor_de_fichero | nombre_de_fichero])</code></a></h3>

<p>Cuando se invoca con un nombre de fichero entonces lo abre (en modo texto), y establece su manejador de fichero como fichero de entrada por defecto. Cuando se llama con un descriptor de fichero simplemente lo establece como manejador para el fichero de entrada por defecto.
Cuando se invoca sin argumento devuelve el fichero por defecto actual. 

<p>En caso de errores esta función activa <code>error</code> en lugar de devolver un código de error.

<hr><h3><a name="pdf-io.lines"><code>io.lines ([nombre_de_fichero])</code></a></h3>


<p>Abre el fichero de nombre dado en modo lectura y devuelve una función iteradora que, cada vez que es invocada, devuelve una nueva línea del fichero. Por tanto, la construcción
<pre>       for linea in io.lines(nombre_de_fichero) do <em>bloque</em> end
</pre>
iterará sobre todas las líneas del fichero. Cuando la función iteradora detecta el final del fichero devuelve <b>nil</b> (para acabar el bucle) y cierra automáticamente el fichero.

<p>La llamada a <code>io.lines()</code> (sin nombre de fichero) equivale a <code>io.input():lines()</code>; esto es, itera sobre todas las líneas del fichero por defecto de entrada. En ese caso no cierra el fichero cuando acaba el bucle.

<hr><h3><a name="pdf-io.open"><code>io.open (nombre_de_fichero [, modo])</code></a></h3>


<p>Esta función abre un fichero, en el modo especificado en el <em>string</em> <code>mode</code>. Devuelve un descriptor de fichero o, en caso de error, <b>nil</b> además de un mensaje de error.

<p>El <em>string</em> que indica <code>modo</code> puede ser uno de los siguientes:
<ul>
<li><b>"r":</b> modo lectura (por defecto);
</li><li><b>"w":</b> modo escritura;
</li><li><b>"a":</b> modo adición;
</li><li><b>"r+":</b> modo actualización, todos los datos preexistentes se mantienen;
</li><li><b>"w+":</b> modo actualización, todos los datos preexistentes se borran;
</li><li><b>"a+":</b> modo adición con actualización, todos los datos preexistentes se mantienen, y la escritura se permite sólo al final del fichero.
</li></ul>
El <em>string</em> que indica el <code>modo</code> puede contener también '<code>b</code>' al final, lo que es necesario en algunos sistemas para abrir el fichero en modo binario. Este <em>string</em> es exactamente el que se usa en la función estándar de C <code>fopen</code>.

<hr><h3><a name="pdf-io.output"><code>io.output ([descriptor_de_fichero | nombre_de_fichero])</code></a></h3>


<p>Similar a <a href="#pdf-io.input"><code>io.input</code></a>, pero operando sobre el fichero por defecto de salida.

<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, modo])</code></a></h3>


<p>Comienza a ejecutar el programa <code>prog</code> en un proceso separado y retorna un descriptor de fichero que se puede usar para leer datos que escribe <code>prog</code> (si <code>modo</code> es <code>"r"</code>, el valor por defecto) o para escribir datos que lee <code>prog</code> (si <code>modo</code> es <code>"w"</code>).

<p>Esta función depende del sistema operativo y no está disponible en todas las plataformas.

<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>

<p>Equivalente a <code>io.input():read</code>.

<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>Devuelve un descriptor de fichero para un fichero temporal. Éste se abre en modo actualización y se elimina automáticamente cuando acaba el programa.

<hr><h3><a name="pdf-io.type"><code>io.type (objeto)</code></a></h3>


<p>Verifica si <code>objeto</code> es un descriptor válido de fichero. Devuelve el <em>string</em> <code>"file"</code> si <code>objeto</code> es un descriptor de fichero abierto, <code>"closed file"</code> si <code>objeto</code> es un descriptor de fichero cerrado, o <b>nil</b> si <code>objeto</code> no es un descriptor de fichero.

<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>


<p>Equivalente a <code>io.output():write</code>.

<hr><h3><a name="pdf-file:close"><code>descriptor_de_fichero:close ()</code></a></h3>



<p>Cierra el descriptor de fichero <code>descriptor_de_fichero</code>. Téngase en cuenta que los ficheros son cerrados automáticamente cuando sus descriptores se eliminan en un ciclo de liberación de memoria, pero que esto toma un tiempo impredecible de ejecución.

<hr><h3><a name="pdf-file:flush"><code>descriptor_de_fichero:flush ()</code></a></h3>


<p>Salva cualquier dato escrito en <code>descriptor_de_fichero</code>.

<hr><h3><a name="pdf-file:lines"><code>descriptor_de_fichero:lines ()</code></a></h3>

<p>Devuelve una función iteradora que, cada vez que es invocada, devuelve una nueva línea leída del fichero. Por tanto, la construcción
<pre>       for linea in descriptor_de_fichero:lines() do <em>bloque</em> end
</pre>
iterará sobre todas las líneas del fichero. (A diferencia de <a href="#pdf-io.lines"><code>io.lines</code></a>, esta función no cierra el fichero cuando acaba el bucle.)

<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>



<p>Lee en el fichero dado por el <code>descriptor_de_fichero</code>, de acuerdo el formato proporcionado, el cual especifica qué leer. Para cada formato, la función devuelve un <em>string</em> (o un número) con los caracteres leídos, o <b>nil</b> si no pudo leer los datos con el formato especificado. Cuando se invoca sin formato se usa uno por defecto que lee la próxima línea completa (véase más abajo).


<p>Los formatos disponibles son
<ul>
<li><b>"*n":</b> lee un número; éste es el único formato que devuelve un número en lugar de un <em>string</em>.
</li><li><b>"*a":</b> lee el resto del fichero completo, empezando en la posición actual. Al final del fichero devuelve un <em>string</em> vacío.
</li><li><b>"*l":</b> lee la próxima línea (saltándose el final de línea), retornando <b>nil</b> al final del fichero. Éste es el formato por defecto.
</li><li><b><em>un número</em>:</b> lee un <em>string</em> con como máximo este número de caracteres, devolviendo <b>nil</b> si se llega al final del fichero. Si el número es cero no lee nada y devuelve un <em>string</em> vacío, o <b>nil</b> si se alcanza el final del fichero.
</li></ul>

<hr><h3><a name="pdf-file:seek"><code>file:seek ([de_dónde] [, desplazamiento])</code></a></h3>


<p>Establece (o solicita) la posición actual (del puntero de lectura/escritura) en el <code>descriptor_de_fichero</code>, medida desde el principio del fichero, en la posición dada por <code>desplazamiento</code> más la base especificada por el <em>string</em> <code>dónde</code>, como se especifica a continuación:
<ul>
<li><b>"set":</b> sitúa la posición base en 0 (comienzo del fichero);
</li><li><b>"cur":</b> sitúa la posición base en la actual;
</li><li><b>"end":</b> sitúa la posición base al final del fichero.
</li></ul>
En caso de éxito la función <code>seek</code> retorna la posición final (del puntero de lectura/escritura) en el fichero medida en bytes desde el principio del fichero. Si la llamada falla retorna <b>nil</b>, más un <em>string</em> describiendo el error.

<p>El valor por defecto de <code>dónde</code> es <code>"cur"</code>, y para <code>desplazamiento</code> es 0. Por tanto, la llamada <code>descriptor_de_fichero:seek()</code> devuelve la posición actual, sin cambiarla; la llamada <code>descriptor_de_fichero:seek("set")</code> establece la posición al principio del fichero (y devuelve 0); y la llamada <code>descriptor_de_fichero:seek("end")</code> establece la posición al final del fichero y devuelve su tamaño.

<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (modo [, tamaño])</code></a></h3>


<p>Establece un modo <em>buffer</em> para un fichero de salida. El argumento <code>modo</code> puede ser uno de estos tres:
<ul>
<li><b>"no":</b>
sin <em>buffer</em>; el resultado de cualquier operación de salida se produce inmediatamente.
</li><li><b>"full":</b>
con <em>buffer</em> completo; la operación de salida se realiza sólo cuando el <em>buffer</em> está lleno o cuando se invoca explícitamente la función <a href="#flush"><code>flush</code></a> en el descriptor del fichero.
</li><li><b>"line":</b>
con <em>buffer</em> de línea; la salida se demora hasta que se produce una nueva línea en la salida o existe una entrada de algún fichero especial (como una terminal).
</li></ul>
<p>Para los dos últimos casos, <code>tamaño</code> especifica el tamaño del <em>buffer</em>, en bytes. El valor por defecto es un tamaño adecuado.

<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>

<p>Escribe el valor de sus argumentos en el fichero dado por su <code>descriptor_de_fichero</code>. Los argumentos pueden ser <em>strings</em> o números. Para escribir otros valores úsese <a href="#pdf-tostring"><code>tostring</code></a> o <a href="#pdf-string.format"><code>string.format</code></a> antes que <code>write</code>.

<p><a name="5.8"></a><h2>5.8 - Utilidades del sistema operativo</h2>

<p>Esta biblioteca está implementada a través de la tabla <code>os</code>.

<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>Devuelve una aproximación al total de segundos de CPU usados por el programa.

<hr><h3><a name="pdf-os.date"><code>os.date ([formato [, tiempo]])</code></a></h3>


<p>Devuelve un <em>string</em> o una tabla conteniendo la fecha y hora, formateada
de acuerdo con el <em>string</em> dado en <code>formato</code>.

<p>Si el argumento <code>tiempo</code> está presente entonces ese tiempo concreto es el que se formatea (véase la función <a href="#pdf-os.time"><code>os.time</code></a> para una descripción de este valor). En caso contrario, <code>date</code> formatea el tiempo actual.

<p>Si <code>formato</code> comienza con '<code>!</code>' entonces el tiempo se formatea de acuerdo al Tiempo Universal Coordinado. Después de este carácter opcional, si <code>formato</code> es <code>*t</code> entonces <code>date</code> devuelve una tabla con los siguientes campos: <code>year</code> (cuatro dígitos), <code>month</code> (1--12), <code>day</code> (1--31), <code>hour</code> (0--23), <code>min</code> (0--59), <code>sec</code> (0--61), <code>wday</code> (día de la semana, el domingo es 1), <code>yday</code> (día dentro del año), e <code>isdst</code> (booleano, verdadero si es horario de verano).

<p>Si <code>formato</code> no es <code>*t</code> entonces <code>date</code> devuelve el tiempo como un <em>string</em>, formateado de acuerdo con las mismas reglas que la función <code>strftime</code> de C.

<p>Cuando se invoca sin argumentos <code>date</code> devuelve una representación razonable de la fecha y la hora que depende de la máquina y del sistema local (esto es, <code>os.date()</code> equivale a <code>os.date("%c")</code>).

<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>Devuelve el número de segundos desde el instante <code>t1</code> hasta el <code>t2</code>. En POSIX, Windows y algunos otros sistemas este valor es exactamente  <code>t2</code><em>-</em><code>t1</code>.

<hr><h3><a name="pdf-os.execute"><code>os.execute ([comando])</code></a></h3>

<p>Esta función equivale a la función <code>system</code> de C. Pasa la orden <code>comando</code> para que sea ejecutada en el intérprete de comandos del sistema operativo. Devuelve un código de estatus, que es dependiente del sistema. Si el argumento <code>comando</code> está ausente devuelve un valor no cero si está disponible un intérprete de comandos y cero si no está disponible.

<hr><h3><a name="pdf-os.exit"><code>os.exit ([código])</code></a></h3>

<p>Invoca  la función <code>exit</code> de C, con un <code>código</code> entero opcional, para terminar el programa anfitrión. El valor por defecto de <code>código</code> es el valor correspondiente a éxito.

<hr><h3><a name="pdf-os.getenv"><code>os.getenv (variable)</code></a></h3>


<p>Devuelve el valor asignado a la variable de entorno <code>variable</code>, o <b>nil</b> si la variable no está definida.

<hr><h3><a name="pdf-os.remove"><code>os.remove (nombre_de_fichero)</code></a></h3>



<p>Elimina el fichero o directorio dado. Los directorios deben estar vacíos para poder ser eliminados. Si la función falla retorna <b>nil</b>, más un <em>string</em> describiendo el error.

<hr><h3><a name="pdf-os.rename"><code>os.rename (nombre_viejo, nombre_nuevo)</code></a></h3>


<p>Renombra un fichero o directorio de <code>nombre_viejo</code> a <code>nombre_nuevo</code>. Si la función falla retorna <b>nil</b>, más un <em>string</em> describiendo el error.

<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (local [, categoría])</code></a></h3>


<p>Establece valores en el sistema local del programa. <code>local</code> es un <em>string</em> que especifica un valor local; <code>categoría</code> es un <em>string</em> opcional que describe qué categoría cambiar: <code>"all"</code>, <code>"collate"</code>, <code>"ctype"</code>, <code>"monetary"</code>, <code>"numeric"</code>, or <code>"time"</code>; la categoría por defecto es <code>"all"</code>. Esta función retorna el nombre del nuevo local o <b>nil</b> si la petición no pudo ser aceptada.

<p>Si <code>local</code> es el <em>string</em> vacío, el local actual se establece como el local nativo (que depende de la implementación). Si <code>local</code> es el string <code>"C"</code>, el local actual se establece en el local estándar de C.

<p>Cuando se invoca con <b>nil</b> como primer argumento, esta función retorna sólo el nombre
del local actual en la categoría dada.

<hr><h3><a name="pdf-os.time"><code>os.time ([tabla])</code></a></h3>


<p>Devuelve el tiempo actual cuando se llama sin argumentos, o un tiempo representando la fecha y hora especificadas en la tabla dada. Ésta debe tener los campos <code>year</code>, <code>month</code> y <code>day</code>, y puede tener los campos <code>hour</code>, <code>min</code>, <code>sec</code> e <code>isdst</code> (para una descripción de esos campos, véase la función <a href="#pdf-os.date"><code>os.date</code></a>).

<p>El valor retornado es un número, cuyo significado depende del sistema. En POSIX, Windows y algunos otros sistemas este número cuenta el número de segundos desde alguna fecha inicial dada (la "época"). En otros sistemas el significado no está especificado, y el número retornado por <code>time</code> puede ser usado sólo como argumento de las funciones <code>date</code> y <code>difftime</code>.

<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>Devuelve un <em>string</em> con un nombre de fichero que puede ser usado como fichero temporal. El fichero debe ser abierto explícitamente antes de su uso y también eliminado explícitamente cuando no se necesite más.


<p><a name="5.9"></a><h2>5.9 - La biblioteca de depuración</h2>

<p>Esta biblioteca proporciona a los programas en Lua las funcionalidades de la interface de depuración. Se debe usar con cuidado. Las funciones proporcionadas aquí deben ser usadas exclusivamente para depuración y labores similares, tales como el análisis de código. Por favor, resístase la tentación de usar la biblioteca como una herramienta de programación: puede llegar a ser muy lenta. Además, alguna de sus funciones viola alguna de las asunciones acerca del código en Lua (por ejemplo, que las variables locales de una función no pueden ser accedidas desde fuera de la función o que los <em>userdata</em> no pueden ser cambiados desde el código Lua) y por tanto pueden comprometer código de otra manera seguro.

<p>Todas las funciones de esta biblioteca se proporcionan en la tabla <code>debug</code>.

<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>

<p>Entra en modo interactivo con el usuario, ejecutando cada <em>string</em> que introduce el usuario. Usando comandos simples y otras utilidades de depuración el usuario puede inspeccionar variables globales y locales, cambiar sus valores, evaluar expresiones, etc. Una línea que contiene sólo la palabra <code>cont</code> finaliza esta función, por lo que el programa invocante continúa su ejecución.

<p>Téngase presente que los comandos para <code>degub.debug</code> no están léxicamente anidados dentro de ninguna función, y no tienen acceso directo a las variables locales.

<hr><h3><a name="pdf-debug.getfenv"><code>debug.getfenv (o)</code></a></h3>


<p>Devuelve el entorno del objeto <code>o</code>.

<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([proceso])</code></a></h3>


<p>Devuelve información sobre el <em>hook</em> actual del proceso, en forma de tres valores: la función del <em>hook</em> actual, la máscara del <em>hook</em> actual y el contador del <em>hook</em> actual (como fue establecida por la función <a href="#pdf-debug.sethook"><code>debug.sethook</code></a>).

<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([proceso,] func [, qué])</code></a></h3>


<p>Devuelve una tabla con información acerca de la función <code>func</code>. Se puede dar la función directamente, o se puede dar un número en el lugar de <code>func</code>, lo que significa la función al nivel de ejecución de la llamada de pila: nivel 0 es el de la función actual (<code>getinfo</code> misma); nivel 1 es la función que llamó a <code>getinfo</code>; y así sucesivamente. Si <code>func</code> es un número mayor que el total de funciones activas entonces <code>getinfo</code> retorna <b>nil</b>.

<p>La tabla devuelta contiene todos los campos retornados por <a href="#lua_getinfo"><code>lua_getinfo</code></a>, con el <em>string</em> <code>qué</code> describiendo los campos a rellenar. Por defecto, si no se proporciona <code>qué</code>, se obtiene toda la información disponible. Si está presente, la opción '<code>f</code>' añade un campo denominado <code>func</code> con la función misma. Si está presente, la opción '<code>L</code>' añade un campo denominado <code>activelines</code> con la tabla de líneas válidas.

<p>Por ejemplo, la expresión <code>debug.getinfo(1,"n").nombre</code> retorna una tabla con un nombre para la función actual, si pudo encontrar un nombre razonable, y <code>debug.getinfo(print)</code> retorna una tabla con toda la información disponible sobre la función <a href="#pdf-print"><code>print</code></a>.

<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([proceso,] nivel, local)</code></a></h3>


<p>Esta función devuelve el nombre y el valor de una variable local con índice <code>local</code> de la función al <code>nivel</code> dado de la pila. (El primer argumento o variable local tiene índice 1, y así sucesivamente, hasta la última variable local activa.) La función retorna <b>nil</b> si no existe una variable local con el índice dado, y activa un error cuando se invoca con <code>nivel</code> fuera de rango. (Se puede llamar a <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> para verificar si el nivel es válido.)

<p>Los nombres de variable que comienzan con '<code>(</code>' (paréntesis de abrir) representan variables internas (de control de bucles, temporales y locales de funciones C).

<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (objeto)</code></a></h3>


<p>Devuelve la metatabla del <code>objeto</code> dado o <b>nil</b> si éste no tiene metatabla.

<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>Retorna la tabla de registro (véase <a href="#3.5">&sect;3.5</a>).

<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (func, up)</code></a></h3>


<p>Esta función retorna el nombre y el valor del <em>upvalue</em> con índice <code>up</code> de la función <code>func</code>. La función retorna <b>nil</b> si no hay un <em>upvalue</em> con el índice dado.

<hr><h3><a name="pdf-debug.setfenv"><code>debug.setfenv (objeto, tabla)</code></a></h3>


<p>Establece la <code>tabla</code> de entorno de un <code>objeto</code> dado.

<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([proceso,] func_hook, máscara [, contador])</code></a></h3>


<p>Establece la función <code>func_hook</code> como <em>hook</em>. El <em>string</em> dado en <code>máscara</code> y el número <code>contador</code> describen como se invoca al <em>hook</em>. La máscara puede tener los siguientes caracteres, con el significado indicado:
<ul>
<li><b><code>"c"</code>:</b> El <em>hook</em> se invoca cada vez que Lua llama a una función;
</li><li><b><code>"r"</code>:</b> El <em>hook</em> se invoca cada vez que Lua retorna de una función;
</li><li><b><code>"l"</code>:</b> El <em>hook</em> se invoca cada vez que Lua entra en una nueva línea de código.
</li></ul>
Con un <code>contador</code> diferente de cero el <em>hook</em> se invoca cada ese número de instrucciones.

<p>Cuando se invoca sin argumentos <a href="#pdf-debug.sethook"><code>debug.sethook</code></a> desactiva el <em>hook</em>.

<p>Cuando se invoca el <em>hook</em> su primer argumento es un <em>string</em> describiendo el evento que ha activado su invocación: <code>"call"</code>, <code>"return"</code> (o <code>"tail return"</code>), <code>"line"</code> y <code>"count"</code>. Para los eventos de línea, el <em>hook</em> también devuelve el número de línea como segundo valor. Dentro de un <em>hook</em> se puede invocar a <code>getinfo</code> con nivel 2 para obtener más información acerca de la función en ejecución (nivel 0 es la función <code>getinfo</code> y nivel 1 es la función <em>hook</em>), a no ser que el evento sea <code>"tail return"</code>. En ese caso Lua sólo simula el retorno, y una llamada a <code>getinfo</code> devolverá datos inválidos.

<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([proceso,] nivel, local, valor)</code></a></h3>


<p>Esta función asigna el <code>valor</code> a la variable local con índice <code>local</code> de la función al <code>nivel</code> dado en la pila, retornando el nombre de la variable local. La función retorna <b>nil</b> si no existe una variable local con el índice dado, y activa un error cuando se llama con un <code>nivel</code> fuera de rango. (Se puede invocar <code>getinfo</code> para verificar si el nivel es válido.)

<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (objeto, tabla)</code></a></h3>


<p>Establece <code>tabla</code> (que puede ser <code>nil</code>) como la metatabla del <code>objeto</code> dado.

<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (func, up, valor)</code></a></h3>

<p>Esta función asigna el <code>valor</code> al <em>upvalue</em> con índice <code>up</code> de la función <code>func</code>, retornando el nombre del <em>upvalue</em>. La función retorna <b>nil</b> si no existe el <em>upvalue</em> con el índice dado.

<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([proceso,] [mensaje] [, nivel])</code></a></h3>


<p>Devuelve un <em>string</em> con el "trazado inverso" de la llamada en la pila. Un <code>mensaje</code> opcional se añade al principio del "trazado inverso". 
Un número de <code>nivel</code> opcional indica en qué nivel se comienza el "trazado inverso"
(por defecto es 1, la función que está invocando a <code>traceback</code>).

<p>
<h1>6 - <a name="6">Lua como lenguaje independiente</a></h1>

<p>Aunque Lua ha sido diseñado como un lenguaje de extensión, para ser embebido en programas en C, también es frecuentemente usado como lenguaje independiente. Con la distribución estándar se proporciona un intérprete independiente denominado simplemente <code>lua</code>. Éste incluye todas las bibliotecas estándar, incluyendo la de depuración. Se usa así:
<pre>      lua [opciones] [fichero_de_script [argumentos]]
</pre>
Las opciones son:
<ul>
<li><b><code>-e</code> <em>sentencia</em>:</b> ejecuta el <em>string</em> <em>sentencia</em>;
</li><li><b><code>-l</code> <em>módulo</em>:</b> carga <em>módulo</em> con la función <code>require</code>;
</li><li><b><code>-i</code>:</b> entra en modo interactivo después de ejecutar el <em>fichero_de_script</em>;
</li><li><b><code>-v</code>:</b> imprime información de la versión;
</li><li><b><code>--</code>:</b> deja de procesar opciones en el resto de la línea;
</li><li><b><code>-</code>:</b> toma <code>stdin</code> como fichero para ejecutar y no procesa más opciones.
</li></ul>
Después de gestionar las opciones proporcionadas, <code>lua</code> ejecuta el <em>fichero_de_script</em> dado, pasándole los <em>argumentos</em> dados como <em>strings</em>. Cuando se invoca sin argumentos <code>lua</code> se comporta como <code>lua -v -i</code> cuando la entrada estándar (<code>stdin</code>) es una terminal, y como <code>lua -</code> en otro caso.

<p>Antes de ejecutar cualquier argumento el intérprete comprueba si existe una variable de entorno <code>LUA_INIT</code>. Si su formato es @<em>nombre_de_fichero</em> entonces <code>lua</code> ejecuta este fichero. En otro caso <code>lua</code> ejecuta el propio <em>string</em>.

<p>Todas las opciones se procesan en orden, excepto <code>-i</code>. Por ejemplo, una invocación como
<pre>       $ lua -e'b=1' -e 'print(b)' script.lua
</pre>
primero establecerá el valor de <code>b</code> a 1, luego imprimirá el valor de <code>b</code> (que es '<code>1</code>'), y finalmente ejectuará el fichero <code>script.lua</code> sin argumentos. (Aquí <code>$</code> es el <a href="#prompt"><em>prompt</em></a> del intérprete de comandos del sistema operativo. El de cada sistema concreto puede ser diferente.)

<p>Antes de comenzar a ejecutar <em>fichero_de_script</em> <code>lua</code> recolecta todos los argumentos de la línea de comandos en una tabla global denominada <code>arg</code>. El nombre del <em>fichero_de_script</em> se guarda en el índice 0, el primer argumento depués del nombre del programa se guarda en el índice 1, y así sucesivamente. Cualesquiera argumentos antes del nombre del programa (esto es, el nombre del intérprete más las opciones) van a los índices negativos. Por ejemplo, en la invocación
<pre>       $ lua -la b.lua t1 t2
</pre>
el intérprete primero ejecuta el fichero <code>b.lua</code>, luego crea la tabla
<pre>
   arg = { [-2] = "lua", [-1] = "-la",
           [0] = "b.lua",
           [1] = "t1", [2] = "t2" }
</pre>
y finalmente ejecuta el fichero <code>b.lua</code>. Éste se invoca con <code>arg[1]</code>, <code>arg[2]</code>, &middot;&middot;&middot; como argumentos; también se accede a estos argumentos con la expresión <em>vararg</em> '<code>...</code>'.

<p>En modo interactivo si se escribe una sentencia incompleta el intérprete espera para que sea completada, indicándolo con otro <em>prompt</em> diferente.

<p>Si la variable global <code>_PROMPT</code> contiene un <em>string</em> entonces su valor se usa como <em>prompt</em>. De manera similar, si la variable global <code>_PROMPT2</code> contiene un <em>string</em> su valor se usa como <em>prompt</em> secundario (el que se utiliza durante las sentencias incompletas). Por tanto, ambos <em>prompts</em> pueden ser cambiados directamente en la línea de comandos o en cualquier programa en Lua asignando un valor a <code>_PROMPT</code>. Véase el siguiente ejemplo:
<pre>       $ lua -e"_PROMPT='myprompt&gt; '" -i
</pre>
(la pareja externa de comillas es para el intérprete de comandos del sistema operativo; la interna para Lua). Nótese el uso de <code>-i</code> para entrar en modo interactivo; en otro caso el programa acabaría silenciosamente justo después de la asignación a <code>_PROMPT</code>.

<p>Para permitir el uso de Lua como un intérprete de <em>scripts</em> en los sistemas Unix, el intérprete independiente de Lua se salta la primera línea de un <em>chunk</em> si ésta comienza con <code>#</code>. Por tanto, los programas de Lua pueden convertirse en ejecutables usando <code>chmod +x</code> y la forma <code>#!</code>, como en
<pre>   #!/usr/local/bin/lua
</pre>
(Por supuesto, la localización del intérprete de Lua puede ser diferente en cada máquina. Si <code>lua</code> está en el camino de búsqueda de ejecutables, <code>PATH</code>, entonces
<pre>   #!/usr/bin/env lua
</pre>
es una solución más portable.)
<p>


<h1>7 - <a name="7">Incompatibilidades con la versión anterior</a></h1>


<p>Aquí se listan las incompatibilidades que pueden aparecer cuando se porta un programa de Lua 5.0 a Lua 5.1. Se pueden evitar la mayoría de ellas compilando Lua con las opciones apropiadas (véase el fichero <code>luaconf.h</code>). Sin embargo todas esas opciones de compatibilidad serán eliminadas en la siguiente versión de Lua.


<h2>7.1 - <a name="7.1">Cambios en el lenguaje</a></h2>
<ul>
<li> El sistema de gestión de funciones con un número de argumentos variable cambió desde el pseudoargumento <code>arg</code> con una tabla con argumentos extra a la expresión <em>vararg</em>. (Véase la opción de compilación <code>LUA_COMPAT_VARARG</code> en <code>luaconf.h</code>.)

</li><li> Existe un sutil cambio en el ámbito de las variables implícitas de las sentencias <b>for</b> y <b>repeat</b>.

</li><li> La sintaxis <code>[[...]]</code> para <em>string</em> largo y para comentario largo no permite anidamientos. Se puede usar la nueva sintaxis <code>[=[...]=]</code> en esos casos. (Véase la opción de compilación <code>LUA_COMPAT_LSTR</code> en <code>luaconf.h</code>.)

</li></ul>

<h2>7.2 - <a name="7.2">Cambios en las bibliotecas</a></h2>
<ul>

<li> La función <code>string.gfind</code> ha sido renombrada a <a href="#pdf-string.gmatch"><code>string.gmatch</code></a>. (Véase la opción de compilación <code>LUA_COMPAT_GFIND</code> en <code>luaconf.h</code>.)

</li><li> Cuando se invoca <a href="#pdf-string.gsub"><code>string.gsub</code></a> con una función como su tercer argumento, siempre que esta función devuelva <b>nil</b> o <b>false</b> el <em>string</em> de reemplazamiento es la coincidencia completa en lugar de un <em>string</em> vacío.

</li><li> Se desaconseja el uso de la función <code>table.setn</code>. La función <code>table.getn</code> corresponde al nuevo operador de longitud (<code>#</code>); úsese el operador en lugar de la función. (Véase la opción de compilación <code>LUA_COMPAT_GETN</code> en <code>luaconf.h</code>.)

</li><li> La función <code>loadlib</code> ha sido renombrada a <a href="#pdf-package.loadlib"><code>package.loadlib</code></a>. (Véase la opción de compilación <code>LUA_COMPAT_LOADLIB</code> en <code>luaconf.h</code>.)

</li><li> La función <code>math.mod</code> ha sido renombrada a  <a href="#pdf-math.fmod"><code>math.fmod</code></a>. (Véase la opción de compilación <code>LUA_COMPAT_MOD</code> en <code>luaconf.h</code>.)

</li><li> Se desaconseja el uso de las funciones <code>table.foreach</code> y <code>table.foreachi</code>. En su lugar se puede usar un bucle con <code>pairs</code> o <code>ipairs</code>.

</li><li> Hay cambios sustanciales en la función <a href="#pdf-require"><code>require</code></a> debido al nuevo sistema de módulos. No obstante, el nuevo comportamiento es casi totalmente compatible con el viejo, aunque <code>require</code> obtiene el camino de búsqueda de <a href="#pdf-package.path"><code>package.path</code></a> en lugar de <code>LUA_PATH</code>.

</li><li> La función <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> tiene otros argumentos. Se desaconseja el uso de la función <code>gcinfo</code>; úsese <code>collectgarbage("count")</code> en su lugar.

</li></ul>

<h2>7.3 - <a name="7.3">Cambios en la API</a></h2>
<ul>

<li> Las funciones <code>luaopen_*</code> (para abrir bibliotecas) no pueden ser invocadas directamente como funciones C regulares. Deben ser llamadas a través de Lua, como otra función Lua.

</li><li> La función <code>lua_open</code> ha sido reemplazada por <a href="#lua_newstate"><code>lua_newstate</code></a> para permitir al usuario establecer una función de asignación de memoria. Se puede usar <a href="#luaL_newstate"><code>luaL_newstate</code></a> de la biblioteca estándar para crear un estado con la función estándar de asignación de memoria (basada en <code>realloc</code>).

</li><li> Las funciones <code>luaL_getn</code> y <code>luaL_setn</code> (de la biblioteca auxiliar) no deben usarse. Úsese <a href="#lua_objlen"><code>lua_objlen</code></a> en lugar de <code>luaL_getn</code> y nada en lugar de <code>luaL_setn</code>.

</li><li> La función <code>luaL_openlib</code> ha sido reemplazada por <a href="#luaL_register"><code>luaL_register</code></a>.

</li><li> La función <code>luaL_checkudata</code> ahora provoca un error cuando el valor
dado no es un <em>userdata</em> del tipo esperado. (En Lua 5.0 retornaba NULL.)

</li></ul>
<p>

<h1>8 - <a name="8">La sintaxis completa de Lua</a></h1>


<p>Aquí aparece la sintaxis completa de Lua en la notación BNF extendida. No describe las prioridades de los operadores.

<p>

<p><pre>
   chunk ::= {sentencia ['<b>;</b>']} [última_sentencia['<b>;</b>']]

   bloque ::= chunk

   sentencia ::=  varlist '<b>=</b>' explist  | 
                 llamada_a_func  | 
                 <b>do</b> bloque <b>end</b>  | 
                 <b>while</b> exp <b>do</b> bloque <b>end</b>  | 
                 <b>repeat</b> bloque <b>until</b> exp  | 
                 <b>if</b> exp <b>then</b> bloque {<b>elseif</b> exp <b>then</b> bloque} [<b>else</b> bloque] <b>end</b>  | 
                 <b>for</b> nombre '<b>=</b>' exp '<b>,</b>' exp ['<b>,</b>' exp] <b>do</b> bloque <b>end</b>  | 
                 <b>for</b> lista_de_nombres <b>in</b> explist <b>do</b> bloque <b>end</b>  | 
                 <b>function</b> nombre_de_func cuerpo_de_func  | 
                 <b>local</b> <b>function</b> nombre cuerpo_de_func  | 
                 <b>local</b> lista_de_nombres ['<b>=</b>' explist] 

   última_sentencia ::= <b>return</b> [explist]  |  <b>break</b>

   nombre_de_func ::= nombre {'<b>.</b>' nombre} ['<b>:</b>' nombre]

   varlist ::= var {'<b>,</b>' var}

   var ::=  nombre  |  prefixexp '<b>[</b>' exp '<b>]</b>'  |  prefixexp '<b>.</b>' nombre 

   lista_de_nombres ::= nombre {'<b>,</b>' nombre}

   explist ::= {exp '<b>,</b>'} exp

   exp ::=  <b>nil</b>  |  <b>false</b>  |  <b>true</b>  |  número  |  string  |  '<b>...</b>'  | 
            func  |  prefixexp  |  constructor_de_tabla  | 
            exp operador_binario exp  | operador_unario exp

   prefixexp ::= var  |  llamada_a_func  |  '<b>(</b>' exp '<b>)</b>'

   llamada_a_func ::=  prefixexp arg_actuales  |  prefixexp '<b>:</b>' nombre args_actuales 

   args_actuales ::=  '<b>(</b>' [explist] '<b>)</b>'  |  constructor_de_tabla  |  string 

   func ::= <b>function</b> cuerpo_de_func

   cuerpo_de_func ::= '<b>(</b>' [args_formal_list] '<b>)</b>' bloque <b>end</b>

   args_formal_list ::= lista_de_nombres ['<b>,</b>' '<b>...</b>']  |  '<b>...</b>'

   constructor_de_tabla ::= '<b>{</b>' [lista_de_campos] '<b>}</b>'

   lista_de_campos ::= campo {separador_de_campo campo} [separador_de_campo]

   campo ::= '<b>[</b>' exp '<b>]</b>' '<b>=</b>' exp  |  nombre '<b>=</b>' exp  |  exp

   separador_de_campo ::= '<b>,</b>'  |  '<b>;</b>'

   operador_binario ::= '<b>+</b>'  |  '<b>-</b>'  |  '<b>*</b>'  |  '<b>/</b>'  |  '<b>^</b>'  |  '<b>%</b>'  |
                        '<b>..</b>'  |  '<b>&lt;</b>'  |  '<b>&lt;=</b>'  |  '<b>&gt;</b>'  |  '<b>&gt;=</b>'  |  '<b>==</b>'  |
                        '<b>~=</b>'  |  <b>and</b>  |  <b>or</b>

   operador_unario ::= '<b>-</b>'  |  <b>not</b>  |  '<b>#</b>'

</pre>

<p>


<h1><a name="terminos">Notas sobre la traducción</a></h1>

<p>
He intentado ser lo más fiel posible al original; probablemente hay errores
y erratas; en caso de duda consúltese el <a href="../index.html">original en inglés</a>.

<p>Algunas palabras son de uso tan común en informática que se utilizan en español sin traducir. Otras tienen por traducción una oración completa y por tanto sería bastante poco coherente introducir esa frase en cada lugar. He preferido, por tanto, dejarlas en el texto (indicadas en <em>itálica</em> como es costumbre en español con palabras de otros idiomas), exponiendo aquí la traducción.



<ul>
<li><a name="arrays"></a><em>arrays</em>: vectores, matrices, etc.; un conjunto de datos identificado por un nombre (que se le da a todo el conjunto); los <em>arrays</em> se pueden indexar mediante números enteros o mediante cualquier tipo de dato (en este caso se habla de <em>arrays asociativos</em>).
<li><a name="buffer"></a><em>buffer</em>: se puede traducir por "tampón" (aunque el nombre en inglés es muy utilizado); es un espacio auxiliar de memoria para diversas operaciones.
<li><a name="chunk"></a><em>chunk</em>: unidad de ejecución en Lua, que es simplemente una secuencia de sentencias.
<li><a name="hook"></a><em>hook</em>: en Lua se denomina así a una función en la sombra que se activa al ocurrir ciertos eventos en el código (por ejemplo un retorno de una función); se usa en la depuración del código.
<li><a name="prompt"></a><em>prompt</em>: un indicador de que el intérprete de comandos del sistema operativo está esperando por una entrada del usuario.
<li><a name="script"></a><em>script</em>: normalmente se denominan así a los programas que se interpretan (por oposición a los ejecutables compilados).
<li><a name="string"></a><em>string</em>: una tira o secuencia de caracteres.
<li><a name="upvalue"></a><em>upvalue</em>: una variable no-local, externa a una función (a la que ésta tiene acceso).
<li><a name="userdata"></a><em>userdata</em>: en Lua es un espacio de memoria utilizado por funciones C.
</ul>

<p>Algunas otras palabras han tenido la traducción siguiente:

<ul>
<li><a name="closure"></a><em>closure</em>: instancia (de función).
<li><a name="loop"></a><em>loop</em>: bucle.
<li><a name="statement"></a><em>statement</em>: sentencia.
<li><a name="thread"></a><em>thread</em>: proceso.
</ul>


<hr>
<small>
Last update:
Wed Sep 28 01:06:07 BRT 2011
</small>
<!--
Last change: minor edit
-->

</body>
<!-- Mirrored from www.lua.org/manual/5.1/es/manual.html by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 29 Sep 2011 12:47:35 GMT -->
</html>
